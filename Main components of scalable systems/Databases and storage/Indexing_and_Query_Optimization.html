<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ایندکس‌گذاری و بهینه‌سازی پرس‌وجو در پایگاه‌های داده</title>
    <link rel="stylesheet" href="../../css/style.css">
    <meta name="description" content="ایندکس‌گذاری و بهینه‌سازی پرس‌وجو در پایگاه‌های داده">
    <meta name="keywords" content="طراحی سیستم, مهندسی نرم‌افزار, معماری سیستم">
</head>
<body>
    <header>
        <div class="header-content">
            <a href="../../index.html" class="logo">طراحی سیستم</a>
            <nav>
                <ul class="nav-menu">
                    <li><a href="../../index.html">خانه</a></li>
                    <li><a href="../../index.html#basic-concepts">مفاهیم پایه</a></li>
                    <li><a href="../../index.html#main-components">اجزای اصلی</a></li>
                    <li><a href="../../index.html#scalable-systems">سیستم‌های مقیاس‌پذیر</a></li>
                    <li><a href="../../index.html#advanced-topics">موضوعات پیشرفته</a></li>
                    <li><a href="../../index.html#interviews">مصاحبه</a></li>
                </ul>
            </nav>
            <button class="mobile-menu-toggle">☰</button>
        </div>
    </header>

    <div class="container">
        <main class="main-content">
            <aside class="sidebar">
                
    <h3>ایندکس‌گذاری و بهینه‌سازی پرس‌وجو در پایگاه‌های داده</h3>
    <ul>
        <li><a href="../../../index.html">بازگشت به خانه</a></li>
        <li><a href="../../../index.html#basic-concepts">مفاهیم پایه</a></li>
        <li><a href="../../../index.html#main-components">اجزای اصلی</a></li>
        <li><a href="../../../index.html#scalable-systems">سیستم‌های مقیاس‌پذیر</a></li>
        <li><a href="../../../index.html#advanced-topics">موضوعات پیشرفته</a></li>
        <li><a href="../../../index.html#interviews">آمادگی مصاحبه</a></li>
    </ul>
    
            </aside>

            <article class="content">
                <div class="breadcrumb">
                    <a href="index.html">خانه</a>
<span>/</span>
<span>Main components of scalable systems</span>
<span>/</span>
<span>Databases and storage</span>
<span>/</span>
<span>Indexing_and_Query_Optimization.html</span>
                </div>

                <h1>ایندکس‌گذاری و بهینه‌سازی پرس‌وجو در پایگاه‌های داده</h1>

<p>این سند به بررسی مفاهیم <strong>ایندکس‌گذاری</strong> و <strong>بهینه‌سازی پرس‌وجو</strong> در پایگاه‌های داده می‌پردازد. هدف این است که با ارائه تعاریف، انواع ایندکس‌ها، تکنیک‌های بهینه‌سازی، مثال‌های واقعی، ابزارها، بهترین روش‌ها و دیاگرام‌ها، یک راهنمای جامع و آموزشی برای یادگیری عمیق فراهم شود. این محتوا به زبان فارسی و با فرمت مارک‌داون ارائه شده است تا برای مستندسازی آموزشی و یادگیری اصول طراحی سیستم و بهینه‌سازی پایگاه داده مناسب باشد.</p>

<p>---</p>

<h2>مقدمه: چرا ایندکس‌گذاری و بهینه‌سازی پرس‌وجو در عملکرد پایگاه داده حیاتی هستند؟</h2>

<strong>ایندکس‌گذاری</strong> و <strong>بهینه‌سازی پرس‌وجو</strong> دو تکنیک کلیدی برای بهبود عملکرد پایگاه‌های داده هستند. با افزایش حجم داده‌ها و تعداد کاربران، پایگاه‌های داده باید بتوانند پرس‌وجوها را به‌سرعت و با کارایی بالا پردازش کنند. بدون ایندکس‌گذاری مناسب یا پرس‌وجوهای بهینه، سیستم‌ها ممکن است کند، پرهزینه یا حتی غیرقابل استفاده شوند.

<strong>اهمیت ایندکس‌گذاری و بهینه‌سازی پرس‌وجو:</strong>
<ul><li><strong>عملکرد:</strong> کاهش زمان اجرای پرس‌وجوها برای پاسخ‌گویی سریع به کاربران.</li></ul>
<ul><li><strong>مقیاس‌پذیری:</strong> امکان مدیریت بارهای کاری سنگین در سیستم‌های مقیاس بزرگ.</li></ul>
<ul><li><strong>تجربه کاربری:</strong> تأخیر کم در برنامه‌هایی مانند وب‌سایت‌های تجارت الکترونیک یا برنامه‌های بلادرنگ.</li></ul>
<ul><li><strong>بهره‌وری منابع:</strong> کاهش مصرف CPU، حافظه و دیسک برای صرفه‌جویی در هزینه‌ها.</li></ul>

<p>این تکنیک‌ها برای پایگاه‌های داده رابطه‌ای (مانند MySQL، PostgreSQL) و غیررابطه‌ای (مانند MongoDB) حیاتی هستند و به توسعه‌دهندگان کمک می‌کنند تا سیستم‌های کارآمد و مقیاس‌پذیر طراحی کنند.</p>

<p>---</p>

<h2>ایندکس در پایگاه‌های داده چیست؟</h2>

<h3>تعریف ایندکس</h3>
<strong>ایندکس</strong> ساختاری در پایگاه داده است که برای تسریع در بازیابی داده‌ها از جداول ایجاد می‌شود. ایندکس مانند فهرست یک کتاب عمل می‌کند و به پایگاه داده اجازه می‌دهد تا به‌جای اسکن کل جدول، داده‌های مورد نظر را سریع‌تر پیدا کند.

<h3>انواع ایندکس‌ها</h3>
<ul><li><strong>B-Tree (درخت B):</strong></li></ul>
   - پرکاربردترین نوع ایندکس در پایگاه‌های داده رابطه‌ای.
   - مناسب برای پرس‌وجوهای مبتنی بر محدوده (Range Queries)، برابری (Equality) و مرتب‌سازی.
   - <strong>مثال:</strong> ایندکس روی ستون <code>user_id</code> در MySQL یا PostgreSQL.
<ul><li><strong>Hash:</strong></li></ul>
   - برای پرس‌وجوهای برابری دقیق (Exact Match) بهینه است.
   - مناسب برای جستجوهای ساده، اما برای محدوده‌ها یا مرتب‌سازی کارآمد نیست.
   - <strong>مثال:</strong> استفاده در Redis یا برخی تنظیمات خاص PostgreSQL.
<ul><li><strong>Full-Text:</strong></li></ul>
   - برای جستجوی متنی در داده‌های بزرگ (مانند مقالات یا نظرات) طراحی شده است.
   - از الگوریتم‌های خاص مانند inverted index استفاده می‌کند.
   - <strong>مثال:</strong> جستجوی تمام‌متن در PostgreSQL یا Elasticsearch.
<ul><li><strong>Bitmap:</strong></li></ul>
   - برای ستون‌هایی با تعداد مقادیر متمایز کم (مانند جنسیت یا وضعیت) مناسب است.
   - فضای کمتری مصرف می‌کند و برای پرس‌وجوهای تحلیلی بهینه است.
   - <strong>مثال:</strong> در Oracle یا PostgreSQL.
<ul><li><strong>Spatial (فضایی):</strong></li></ul>
   - برای داده‌های جغرافیایی مانند مختصات GPS استفاده می‌شود.
   - <strong>مثال:</strong> PostGIS در PostgreSQL برای نقشه‌ها.
<ul><li><strong>Clustered vs Non-Clustered:</strong></li></ul>
   - <strong>Clustered:</strong> داده‌های جدول به‌صورت فیزیکی بر اساس ایندکس مرتب می‌شوند (هر جدول تنها یک ایندکس کلاسترد می‌تواند داشته باشد).
   - <strong>Non-Clustered:</strong> ایندکس جدا از داده‌های جدول ذخیره می‌شود.

<h3>نحوه عملکرد داخلی ایندکس‌ها</h3>
<ul><li>ایندکس‌ها ساختارهای داده‌ای (مانند B-Tree یا Hash Table) هستند که اشاره‌گرهایی به داده‌های جدول دارند.</li></ul>
<ul><li><strong>B-Tree:</strong> داده‌ها را در یک ساختار درختی متعادل ذخیره می‌کند که جستجوهای لگاریتمی (O(log n)) را امکان‌پذیر می‌کند.</li></ul>
<ul><li><strong>Hash:</strong> از یک تابع هش برای نگاشت کلیدها به مکان‌های داده استفاده می‌کند، که جستجوی O(1) را برای برابری فراهم می‌کند.</li></ul>
<ul><li><strong>فرآیند:</strong> وقتی یک پرس‌وجو اجرا می‌شود، موتور پایگاه داده از ایندکس برای یافتن سریع داده‌ها استفاده می‌کند، به‌جای اسکن کامل جدول (Full Table Scan).</li></ul>

<h3>استراتژی‌های ایندکس‌گذاری</h3>
<ul><li><strong>انتخاب ستون‌های مناسب:</strong> ستون‌هایی که در شرط‌های WHERE، JOIN، GROUP BY یا ORDER BY استفاده می‌شوند.</li></ul>
<ul><li><strong>ایندکس‌های مرکب (Composite Indexes):</strong> برای پرس‌وجوهایی که چندین ستون را شامل می‌شوند (مانند <code>INDEX(user_id, order_date)</code>).</li></ul>
<ul><li><strong>ایندکس‌های جزئی (Partial Indexes):</strong> برای زیرمجموعه‌ای از داده‌ها (مانند ایندکس روی سفارشات فعال).</li></ul>
<ul><li><strong>اجتناب از ایندکس‌های غیرضروری:</strong> ایندکس‌های بیش‌ازحد می‌توانند عملکرد را کاهش دهند.</li></ul>

<p>---</p>

<h2>مزایا و معایب استفاده از ایندکس‌ها</h2>

<h3>مزایا</h3>
<ul><li><strong>افزایش سرعت پرس‌وجوها:</strong> کاهش زمان اجرای SELECT، JOIN و WHERE.</li></ul>
<ul><li><strong>بهبود عملکرد در مقیاس بزرگ:</strong> به‌ویژه برای جداول با میلیون‌ها ردیف.</li></ul>
<ul><li><strong>پشتیبانی از پرس‌وجوهای پیچیده:</strong> مانند مرتب‌سازی یا جستجوی محدوده.</li></ul>

<h3>معایب</h3>
<ul><li><strong>مصرف فضای ذخیره‌سازی:</strong> ایندکس‌ها فضای اضافی روی دیسک اشغال می‌کنند.</li></ul>
<ul><li><strong>کاهش سرعت نوشتن:</strong> عملیات INSERT، UPDATE و DELETE کندتر می‌شوند، زیرا ایندکس‌ها باید به‌روزرسانی شوند.</li></ul>
<ul><li><strong>پیچیدگی نگهداری:</strong> نیاز به مدیریت و بهینه‌سازی دوره‌ای ایندکس‌ها.</li></ul>
<ul><li><strong>عملکرد منفی در صورت استفاده نادرست:</strong> ایندکس‌های نامناسب می‌توانند پرس‌وجوها را کندتر کنند.</li></ul>

<p>---</p>

<h2>تأثیر ایندکس‌ها بر عملکرد</h2>

<h3>بهبود عملکرد</h3>
<ul><li><strong>جستجوی سریع‌تر:</strong> ایندکس‌ها زمان جستجو را از O(n) (اسکن کامل) به O(log n) یا حتی O(1) کاهش می‌دهند.</li></ul>
<ul><li><strong>کاهش I/O دیسک:</strong> با محدود کردن داده‌های خوانده‌شده، مصرف منابع کاهش می‌یابد.</li></ul>
<ul><li><strong>مثال:</strong> یک جدول با ۱ میلیون ردیف بدون ایندکس ممکن است برای یافتن یک کاربر ۵ ثانیه طول بکشد، اما با ایندکس B-Tree این زمان به چند میلی‌ثانیه کاهش می‌یابد.</li></ul>

<h3>زمانی که ایندکس‌ها ممکن است به عملکرد آسیب بزنند</h3>
<ul><li><strong>عملیات نوشتن سنگین:</strong> هر تغییر در داده‌ها (INSERT/UPDATE/DELETE) نیاز به به‌روزرسانی ایندکس دارد.</li></ul>
<ul><li><strong>انتخاب نادرست ایندکس:</strong> اگر پرس‌وجو از ایندکس استفاده نکند (مانند استفاده از تابع روی ستون ایندکس‌شده)، عملکرد بهبود نمی‌یابد.</li></ul>
<ul><li><strong>تعداد زیاد ایندکس‌ها:</strong> می‌تواند تصمیم‌گیری بهینه‌ساز (Optimizer) را پیچیده کند.</li></ul>

<p>---</p>

<h2>بهینه‌سازی پرس‌وجو</h2>

<h3>بهینه‌سازی پرس‌وجو چیست و چرا لازم است؟</h3>
<strong>بهینه‌سازی پرس‌وجو</strong> فرآیند بهبود پرس‌وجوهای پایگاه داده برای کاهش زمان اجرا، مصرف منابع و بهبود کارایی است. این کار شامل نوشتن پرس‌وجوهای کارآمد، استفاده از ایندکس‌های مناسب و کمک به موتور پایگاه داده برای انتخاب بهترین برنامه اجرایی (Execution Plan) است.

<strong>چرا لازم است؟</strong>
<ul><li>کاهش تأخیر برای تجربه کاربری بهتر.</li></ul>
<ul><li>کاهش مصرف منابع (CPU، حافظه، دیسک) برای صرفه‌جویی در هزینه‌ها.</li></ul>
<ul><li>پشتیبانی از مقیاس‌پذیری در برنامه‌های با ترافیک بالا.</li></ul>

<h3>نحوه بهینه‌سازی پرس‌وجوها توسط موتور پایگاه داده</h3>
<ul><li><strong>برنامه‌ریز پرس‌وجو (Query Planner):</strong> موتور پایگاه داده (مانند MySQL یا PostgreSQL) یک برنامه اجرایی برای پرس‌وجو ایجاد می‌کند.</li></ul>
<ul><li><strong>برآورد هزینه (Cost Estimation):</strong> برنامه‌ریز هزینه هر مسیر اجرایی (مانند استفاده از ایندکس یا اسکن کامل) را تخمین می‌زند و کم‌هزینه‌ترین را انتخاب می‌کند.</li></ul>
<ul><li><strong>آمار جدول:</strong> پایگاه داده از آمار (مانند تعداد ردیف‌ها یا توزیع داده‌ها) برای تصمیم‌گیری استفاده می‌کند.</li></ul>

<h3>تکنیک‌های نوشتن پرس‌وجوهای کارآمد</h3>
<ul><li><strong>انتخاب ستون‌های خاص:</strong> به‌جای <code>SELECT *</code>، ستون‌های مورد نیاز را مشخص کنید.</li></ul>
   - <strong>مثال:</strong> <code>SELECT name, email FROM users</code> به‌جای <code>SELECT * FROM users</code>.
<ul><li><strong>استفاده از ایندکس‌ها:</strong> ستون‌های موجود در شرط‌های WHERE، JOIN و ORDER BY را ایندکس کنید.</li></ul>
<ul><li><strong>اجتناب از توابع روی ستون‌های ایندکس‌شده:</strong> مانند <code>WHERE UPPER(name) = 'ALI'</code> که از ایندکس استفاده نمی‌کند.</li></ul>
<ul><li><strong>استفاده از JOINهای بهینه:</strong> از INNER JOIN به‌جای LEFT JOIN در صورت امکان استفاده کنید.</li></ul>
<ul><li><strong>تقسیم پرس‌وجوهای پیچیده:</strong> پرس‌وجوهای بزرگ را به بخش‌های کوچکتر تقسیم کنید.</li></ul>
<ul><li><strong>استفاده از LIMIT:</strong> برای محدود کردن تعداد ردیف‌های بازگشتی در پرس‌وجوهای بزرگ.</li></ul>

<h3>الگوهای ضدعملکرد (Anti-Patterns)</h3>
<ul><li><strong>استفاده از <code>SELECT *</code>:</strong> باعث خواندن داده‌های غیرضروری و افزایش I/O می‌شود.</li></ul>
<ul><li><strong>پرس‌وجوهای بدون ایندکس:</strong> منجر به اسکن کامل جدول می‌شود.</li></ul>
<ul><li><strong>استفاده از توابع روی ستون‌های ایندکس‌شده:</strong> مانند <code>WHERE DATE(created_at) = '2025-07-11'</code> که ایندکس را غیرقابل استفاده می‌کند.</li></ul>
<ul><li><strong>Joinهای بیش‌ازحد:</strong> می‌تواند پرس‌وجو را بسیار کند کند.</li></ul>
<ul><li><strong>عدم به‌روزرسانی آمار:</strong> آمار قدیمی می‌تواند باعث انتخاب برنامه اجرایی ناکارآمد شود.</li></ul>

<p>---</p>

<h2>ابزارها و دستورات برای تحلیل پرس‌وجوها</h2>

<ul><li><strong>EXPLAIN (یا EXPLAIN PLAN):</strong></li></ul>
   - نمایش برنامه اجرایی پرس‌وجو، شامل استفاده از ایندکس‌ها، نوع اسکن و هزینه.
   - <strong>مثال در MySQL:</strong> <code>EXPLAIN SELECT * FROM users WHERE user_id = 100;</code>
   - <strong>مثال در PostgreSQL:</strong> <code>EXPLAIN ANALYZE SELECT * FROM users WHERE user_id = 100;</code>

<ul><li><strong>ANALYZE:</strong></li></ul>
   - به‌روزرسانی آمار جدول برای کمک به برنامه‌ریز در انتخاب بهترین برنامه اجرایی.
   - <strong>مثال در PostgreSQL:</strong> <code>ANALYZE users;</code>

<ul><li><strong>SHOW INDEX:</strong></li></ul>
   - نمایش ایندکس‌های موجود در یک جدول.
   - <strong>مثال در MySQL:</strong> <code>SHOW INDEX FROM users;</code>

<ul><li><strong>ابزارهای مانیتورینگ:</strong></li></ul>
   - <strong>pg_stat_statements (PostgreSQL):</strong> برای تحلیل پرس‌وجوهای پرتکرار.
   - <strong>Performance Schema (MySQL):</strong> برای نظارت بر عملکرد پایگاه داده.
   - <strong>MongoDB Profiler:</strong> برای بررسی پرس‌وجوهای کند.

<ul><li><strong>ابزارهای خارجی:</strong></li></ul>
   - <strong>pgAdmin/MySQL Workbench:</strong> برای تجزیه و تحلیل بصری پرس‌وجوها.
   - <strong>Prometheus/Grafana:</strong> برای مانیتورینگ عملکرد در مقیاس بزرگ.

<p>---</p>

<h2>مثال‌های واقعی: پرس‌وجوهای کند در مقابل بهینه</h2>

<h3>مثال ۱: پرس‌وجوی کند</h3>
<strong>سناریو:</strong> یک جدول <code>orders</code> با ۱ میلیون ردیف بدون ایندکس روی ستون <code>order_date</code>.
<pre><code>sql
SELECT * FROM orders WHERE DATE(order_date) = '2025-07-11';
</code></pre>
<ul><li><strong>مشکل:</strong> استفاده از تابع <code>DATE()</code> مانع استفاده از ایندکس می‌شود و منجر به اسکن کامل جدول می‌شود.</li></ul>
<ul><li><strong>زمان اجرا:</strong> ممکن است چند ثانیه طول بکشد.</li></ul>

<strong>نسخه بهینه:</strong>
<ul><li>ایندکس روی <code>order_date</code> ایجاد کنید:</li></ul>
   <pre><code>sql
   CREATE INDEX idx_order_date ON orders(order_date);
   </code></pre>
<ul><li>پرس‌وجو را بازنویسی کنید:</li></ul>
   <pre><code>sql
   SELECT * FROM orders WHERE order_date >= '2025-07-11 00:00:00' AND order_date < '2025-07-12 00:00:00';
   </code></pre>
<ul><li><strong>بهبود:</strong> استفاده از ایندکس و حذف تابع روی ستون، زمان اجرا را به چند میلی‌ثانیه کاهش می‌دهد.</li></ul>

<h3>مثال ۲: پرس‌وجوی پیچیده</h3>
<strong>سناریو:</strong> جدول <code>users</code> و <code>orders</code> با JOIN بدون ایندکس.
<pre><code>sql
SELECT u.name, o.order_id FROM users u JOIN orders o ON u.user_id = o.user_id WHERE o.status = 'completed';
</code></pre>
<ul><li><strong>مشکل:</strong> بدون ایندکس روی <code>user_id</code> و <code>status</code>، پرس‌وجو کند است.</li></ul>
<ul><li><strong>نسخه بهینه:</strong></li></ul>
  <pre><code>sql
  CREATE INDEX idx_user_id ON orders(user_id);
  CREATE INDEX idx_status ON orders(status);
  </code></pre>
  - <strong>بهبود:</strong> ایندکس‌ها به JOIN و فیلتر سریع‌تر کمک می‌کنند.

<p>---</p>

<h2>بهترین روش‌ها برای ایندکس‌گذاری و بهینه‌سازی در برنامه‌های پرترافیک</h2>

<ul><li><strong>انتخاب ستون‌های مناسب برای ایندکس:</strong></li></ul>
   - ستون‌های استفاده‌شده در WHERE، JOIN، GROUP BY و ORDER BY را ایندکس کنید.
   - از ایندکس‌های مرکب برای پرس‌وجوهای چندستونی استفاده کنید.
<ul><li><strong>اجتناب از ایندکس‌های بیش‌ازحد:</strong></li></ul>
   - ایندکس‌های غیرضروری فضای دیسک را اشغال کرده و عملیات نوشتن را کند می‌کنند.
<ul><li><strong>به‌روزرسانی آمار جدول:</strong></li></ul>
   - به‌طور دوره‌ای دستور <code>ANALYZE</code> را اجرا کنید تا برنامه‌ریز از آمار به‌روز استفاده کند.
<ul><li><strong>نوشتن پرس‌وجوهای کارآمد:</strong></li></ul>
   - از <code>SELECT *</code> اجتناب کنید و ستون‌های خاص را مشخص کنید.
   - از LIMIT برای کاهش تعداد ردیف‌های بازگشتی استفاده کنید.
<ul><li><strong>مانیتورینگ و پروفایلینگ:</strong></li></ul>
   - از ابزارهایی مانند <code>EXPLAIN</code> و <code>pg_stat_statements</code> برای شناسایی پرس‌وجوهای کند استفاده کنید.
   - معیارهای عملکرد را با Prometheus و Grafana نظارت کنید.
<ul><li><strong>تست در محیط‌های واقعی:</strong></li></ul>
   - پرس‌وجوها را با داده‌های واقعی و بارهای کاری شبیه‌سازی‌شده تست کنید.
<ul><li><strong>استفاده از کشینگ:</strong></li></ul>
   - از ابزارهایی مانند Redis یا Memcached برای کش کردن نتایج پرس‌وجوهای پرتکرار استفاده کنید.
<ul><li><strong>مدیریت شاردینگ و پارتیشن‌بندی:</strong></li></ul>
   - برای جداول بزرگ، از پارتیشن‌بندی یا شاردینگ برای بهبود عملکرد استفاده کنید.

<p>---</p>

<h2>خلاصه و نکات کلیدی</h2>

<ul><li><strong>ایندکس‌گذاری</strong> با کاهش زمان جستجو و بهبود عملکرد پرس‌وجوها، کارایی پایگاه داده را افزایش می‌دهد.</li></ul>
<ul><li><strong>انواع ایندکس‌ها:</strong> B-Tree برای پرس‌وجوهای عمومی، Hash برای برابری، Full-Text برای جستجوی متنی و Spatial برای داده‌های جغرافیایی.</li></ul>
<ul><li><strong>بهینه‌سازی پرس‌وجو</strong> شامل نوشتن پرس‌وجوهای کارآمد، استفاده از ایندکس‌های مناسب و کمک به برنامه‌ریز برای انتخاب بهترین برنامه اجرایی است.</li></ul>
<ul><li><strong>مزایا و معایب:</strong> ایندکس‌ها سرعت خواندن را افزایش می‌دهند، اما می‌توانند عملیات نوشتن را کند کنند.</li></ul>
<ul><li><strong>بهترین روش‌ها:</strong></li></ul>
  - ایندکس‌های مناسب را بر اساس الگوهای پرس‌وجو انتخاب کنید.
  - پرس‌وجوهای کند را با ابزارهایی مانند <code>EXPLAIN</code> تحلیل کنید.
  - از کشینگ و پارتیشن‌بندی برای بهبود مقیاس‌پذیری استفاده کنید.

<h3>دیاگرام ایندکس B-Tree</h3>

<pre><code>
       [Root Node]
       /         \
 [Child 1]    [Child 2]
 /    <td>    \    /    </td>    \
[Leaf] [Leaf] [Leaf] [Leaf] [Leaf]
</code></pre>

<strong>توضیح:</strong> ساختار درختی B-Tree که داده‌ها را به‌صورت مرتب ذخیره می‌کند و جستجوی لگاریتمی را فراهم می‌کند.

<h3>جدول مقایسه ایندکس‌ها</h3>

<p><td> <strong>نوع ایندکس</strong> </td> <strong>موارد استفاده</strong>                     <td> <strong>مزایا</strong>                       </td> <strong>معایب</strong>                          |
<td>----------------</td>---------------------------------------<td>----------------------------------</td>------------------------------------|
<td> <strong>B-Tree</strong>     </td> پرس‌وجوهای محدوده، برابری، مرتب‌سازی <td> انعطاف‌پذیر، پرکاربرد         </td> فضای ذخیره‌سازی بیشتر             |
<td> <strong>Hash</strong>       </td> جستجوی برابری دقیق                   <td> سرعت بالا در برابری            </td> نامناسب برای محدوده‌ها           |
<td> <strong>Full-Text</strong>  </td> جستجوی متنی                         <td> بهینه برای متن‌های بزرگ         </td> پیچیدگی در تنظیم و نگهداری       |
<td> <strong>Bitmap</strong>     </td> ستون‌های با مقادیر کم               <td> فضای کم، مناسب برای تحلیل       </td> نامناسب برای داده‌های پویا        |</p>

<p>---</p>

<h2>منابع پیشنهادی برای مطالعه بیشتر</h2>

<ul><li><em>Designing Data-Intensive Applications</em> نوشته مارتین کلپمن: کتابی جامع برای یادگیری ایندکس‌گذاری و بهینه‌سازی پایگاه داده.</li></ul>
<ul><li><em>The System Design Primer</em> (منبع متن‌باز در GitHub): راهنمایی برای بهینه‌سازی پایگاه‌های داده.</li></ul>
<ul><li>وبلاگ‌های مهندسی:</li></ul>
   - <em>MySQL Blog</em>: مقالات در مورد ایندکس‌گذاری و بهینه‌سازی پرس‌وجو.
   - <em>PostgreSQL Blog</em>: توضیحات در مورد <code>EXPLAIN</code> و ایندکس‌های پیشرفته.
   - <em>MongoDB Blog</em>: مقالات در مورد ایندکس‌گذاری در پایگاه‌های داده NoSQL.
<ul><li>دوره‌های آنلاین:</li></ul>
   - <em>Grokking the System Design Interview</em> در DesignGuru.io
   - <em>System Design Course</em> در Educative.io
<ul><li>مستندات رسمی:</li></ul>
   - <a href="https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html">MySQL Indexing</a>
   - <a href="https://www.postgresql.org/docs/current/using-explain.html">PostgreSQL EXPLAIN</a>
   - <a href="https://www.mongodb.com/docs/manual/indexes/">MongoDB Indexes</a>

<p>---</p>

<p>این سند مفهوم ایندکس‌گذاری و بهینه‌سازی پرس‌وجو را به‌صورت جامع توضیح می‌دهد و برای مستندسازی آموزشی و یادگیری طراحی سیستم مناسب است. در صورت نیاز به توضیحات عمیق‌تر یا مثال‌های بیشتر، لطفاً اطلاع دهید!</p>

                <div class="alert alert-info" style="margin-top: 2rem;">
                    <strong>نکته:</strong> این مطلب بخشی از مجموعه آموزش طراحی سیستم است. برای مطالعه سایر مطالب، از منوی کناری استفاده کنید.
                </div>
            </article>
        </main>
    </div>

    <footer>
        <div class="footer-content">
            <p>&copy; 2024 آموزش طراحی سیستم - تمام حقوق محفوظ است</p>
            <p>آخرین به‌روزرسانی: 2025-07-12</p>
        </div>
    </footer>

    <script src="../../js/script.js"></script>
</body>
</html>
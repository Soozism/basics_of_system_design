# مفهوم کشینگ و اهمیت آن در بهبود عملکرد سیستم

این سند به بررسی مفهوم **کشینگ (Caching)** و نقش آن در بهبود عملکرد سیستم‌های مقیاس‌پذیر می‌پردازد. هدف این است که با ارائه تعاریف، انواع کشینگ، موارد استفاده، مزایا و چالش‌ها، سیاست‌های حذف کش، مثال‌های واقعی، بهترین روش‌ها و منابع پیشنهادی، یک راهنمای جامع و آموزشی برای یادگیری طراحی سیستم فراهم شود. این محتوا به زبان فارسی و با فرمت مارک‌داون ارائه شده است تا برای مستندسازی آموزشی و یادگیری اصول طراحی سیستم مناسب باشد.

---

## مقدمه: کشینگ چیست و چرا اهمیت دارد؟

**کشینگ** تکنیکی است که در آن داده‌های پراستفاده یا پرهزینه (از نظر محاسباتی یا زمانی) در یک حافظه سریع ذخیره می‌شوند تا دسترسی بعدی به آن‌ها سریع‌تر انجام شود. کشینگ یکی از ابزارهای کلیدی در طراحی سیستم‌های مقیاس‌پذیر است که به بهبود عملکرد، کاهش تأخیر و افزایش مقیاس‌پذیری کمک می‌کند.

**چرا کشینگ مهم است؟**
- **کاهش تأخیر:** با ذخیره‌سازی داده‌ها در حافظه سریع (مانند RAM یا SSD)، زمان پاسخ‌گویی به کاربران کاهش می‌یابد.
- **مقیاس‌پذیری:** کاهش بار روی پایگاه‌های داده و سرورهای اصلی، امکان پشتیبانی از کاربران بیشتر را فراهم می‌کند.
- **صرفه‌جویی در منابع:** کاهش استفاده از CPU، دیسک و شبکه، هزینه‌های زیرساختی را کاهش می‌دهد.
- **تجربه کاربری:** پاسخ‌های سریع‌تر به کاربران تجربه بهتری ارائه می‌دهد، به‌ویژه در برنامه‌های بلادرنگ مانند وب‌سایت‌های تجارت الکترونیک یا شبکه‌های اجتماعی.

---

## تعریف کش و مکانیزم‌های کشینگ

**کش (Cache)** حافظه‌ای سریع و موقت است که داده‌های پراستفاده یا نتایج محاسبات سنگین را ذخیره می‌کند تا دسترسی بعدی سریع‌تر و کم‌هزینه‌تر باشد. **کشینگ** فرآیند ذخیره‌سازی و بازیابی این داده‌ها است.

**مکانیزم‌های کشینگ:**
- **Write-Through:** داده‌ها همزمان به کش و حافظه اصلی نوشته می‌شوند. این روش سازگاری داده‌ها را تضمین می‌کند، اما ممکن است کندتر باشد.
- **Write-Back:** داده‌ها ابتدا به کش نوشته می‌شوند و بعداً به حافظه اصلی منتقل می‌شوند. این روش سریع‌تر است، اما خطر ناسازگاری در صورت خرابی وجود دارد.
- **Write-Around:** داده‌ها مستقیماً به حافظه اصلی نوشته می‌شوند و کش فقط برای خواندن استفاده می‌شود.
- **Read-Through:** داده‌ها از کش خوانده می‌شوند و در صورت نبود، از حافظه اصلی بارگذاری شده و به کش اضافه می‌شوند.
- **Cache-Aside (Lazy Loading):** برنامه مسئول بارگذاری داده‌ها به کش است. در صورت Cache Miss، داده‌ها از منبع اصلی بارگذاری شده و به کش اضافه می‌شوند.

**مثال:** در یک وب‌سایت، نتایج یک پرس‌وجوی پایگاه داده (مانند لیست محصولات) در Redis ذخیره می‌شود تا درخواست‌های بعدی سریع‌تر پاسخ داده شوند.

---

## چگونه کشینگ عملکرد، زمان پاسخ‌گویی و مقیاس‌پذیری را بهبود می‌بخشد؟

### بهبود عملکرد
- **کاهش زمان دسترسی:** حافظه کش (مانند RAM) بسیار سریع‌تر از دیسک یا پایگاه داده است. مثلاً، دسترسی به داده در Redis می‌تواند در میکروثانیه انجام شود، در حالی که پرس‌وجوی پایگاه داده ممکن است میلی‌ثانیه طول بکشد.
- **کاهش بار محاسباتی:** ذخیره‌سازی نتایج محاسبات سنگین (مانند رندر صفحات وب) از تکرار محاسبات جلوگیری می‌کند.

### کاهش زمان پاسخ‌گویی
- **تأخیر کمتر:** کشینگ داده‌های پراستفاده (مانند پروفایل کاربر) زمان پاسخ‌گویی به درخواست‌های کاربر را کاهش می‌دهد.
- **مثال:** در آمازون، ذخیره‌سازی داده‌های سبد خرید در DynamoDB Accelerator (DAX) تأخیر را به میکروثانیه کاهش می‌دهد.

### افزایش مقیاس‌پذیری
- **کاهش بار پایگاه داده:** با پاسخ‌گویی به درخواست‌ها از کش، بار روی پایگاه‌های داده کاهش می‌یابد، که امکان پشتیبانی از تعداد بیشتری کاربر را فراهم می‌کند.
- **مثال:** در رویدادهای پرترافیک مانند Black Friday، کشینگ به آمازون کمک می‌کند تا میلیون‌ها درخواست در ثانیه را مدیریت کند.

---

## انواع کشینگ

### ۱. کشینگ سمت کاربر (Client-Side Caching)
- **تعریف:** ذخیره‌سازی داده‌ها در مرورگر یا دستگاه کاربر (مانند حافظه مرورگر یا Local Storage).
- **ویژگی‌ها:**
  - کاهش درخواست‌ها به سرور.
  - مناسب برای داده‌های استاتیک مانند تصاویر، CSS و JavaScript.
- **مثال:** ذخیره‌سازی فایل‌های CSS یک وب‌سایت در کش مرورگر با استفاده از هدرهای `Cache-Control`.

### ۲. کشینگ سمت سرور (Server-Side Caching)
- **تعریف:** ذخیره‌سازی داده‌ها در سرور یا نزدیک به آن (مانند Redis، Memcached یا حافظه داخلی سرور).
- **ویژگی‌ها:**
  - مناسب برای داده‌های پویا مانند نتایج پرس‌وجوهای پایگاه داده.
  - کنترل بیشتر روی سیاست‌های کشینگ و ابطال.
- **مثال:** ذخیره‌سازی نتایج پرس‌وجوی پایگاه داده در Redis برای یک وب‌سایت تجارت الکترونیک.

### ۳. کشینگ شبکه تحویل محتوا (CDN Caching)
- **تعریف:** ذخیره‌سازی داده‌ها در سرورهای لبه (Edge Servers) نزدیک به کاربران در سراسر جهان.
- **ویژگی‌ها:**
  - کاهش تأخیر شبکه با ارائه محتوا از سرورهای نزدیک.
  - مناسب برای محتوای استاتیک مانند تصاویر، ویدئوها و فایل‌های HTML.
- **مثال:** استفاده از CloudFront (AWS CDN) برای ارائه تصاویر محصول در آمازون.

---

## موارد استفاده رایج در طراحی سیستم

1. **نتایج پرس‌وجوهای پایگاه داده:**
   - ذخیره‌سازی نتایج پرس‌وجوهای پرتکرار (مانند لیست محصولات پرطرفدار) در Redis یا Memcached.
   - **مثال:** آمازون نتایج جستجوی محصولات را در DynamoDB Accelerator کش می‌کند.
2. **صفحات HTML رندرشده:**
   - ذخیره‌سازی صفحات رندرشده (مانند صفحات وب استاتیک) برای کاهش بار روی سرورهای وب.
   - **مثال:** وردپرس از افزونه‌های کشینگ مانند WP Super Cache برای ذخیره‌سازی صفحات رندرشده استفاده می‌کند.
3. **پاسخ‌های API:**
   - ذخیره‌سازی پاسخ‌های API برای کاهش درخواست‌ها به سرورهای Backend.
   - **مثال:** اینستاگرام پاسخ‌های API برای فید کاربران را در MongoDB یا Redis کش می‌کند.
4. **داده‌های متادیتا:** ذخیره‌سازی متادیتای پراستفاده مانند اطلاعات پروفایل کاربران یا تنظیمات برنامه.
5. **محاسبات سنگین:** ذخیره‌سازی نتایج محاسبات پیچیده (مانند توصیه‌های شخصی‌سازی‌شده) برای جلوگیری از محاسبه مجدد.

---

## لایه‌های کشینگ و جایگاه کش در معماری سیستم

**لایه‌های کشینگ در معماری سیستم:**
1. **لایه مرورگر (Browser Cache):** داده‌های استاتیک مانند تصاویر و فایل‌های CSS در مرورگر کاربر ذخیره می‌شوند.
2. **لایه CDN:** محتوای استاتیک در سرورهای لبه CDN ذخیره می‌شود تا تأخیر شبکه کاهش یابد.
3. **لایه برنامه (Application Cache):** داده‌های پویا مانند نتایج API یا صفحات رندرشده در حافظه سرور (مانند Redis) ذخیره می‌شوند.
4. **لایه پایگاه داده (Database Cache):** نتایج پرس‌وجوهای پایگاه داده در حافظه‌ای مانند DynamoDB DAX یا Memcached ذخیره می‌شوند.

**جایگاه کش در معماری:**
```
[کاربر] --> [CDN] --> [تعادل‌کننده بار] --> [سرور برنامه]
                                  |                |
                                  v                v
                            [کش (Redis)]   [پایگاه داده]
```

**توضیح:** کش معمولاً بین سرور برنامه و پایگاه داده قرار می‌گیرد تا درخواست‌ها را رهگیری کرده و پاسخ‌های سریع‌تر ارائه دهد.

---

## مزایای استفاده از کشینگ

- **کاهش تأخیر:** دسترسی به داده‌های کش‌شده در حافظه سریع‌تر از پایگاه داده یا دیسک است.
- **افزایش توان عملیاتی:** کاهش بار روی پایگاه داده، توان عملیاتی سیستم را افزایش می‌دهد.
- **مقیاس‌پذیری:** امکان پشتیبانی از تعداد بیشتری کاربر بدون نیاز به سرورهای اضافی.
- **صرفه‌جویی در هزینه‌ها:** کاهش استفاده از منابع گران‌قیمت مانند CPU و دیسک.
- **بهبود تجربه کاربری:** پاسخ‌های سریع‌تر باعث رضایت بیشتر کاربران می‌شود.

---

## چالش‌ها و محدودیت‌های کشینگ

1. **ابطال کش (Cache Invalidation):**
   - یکی از چالش‌های اصلی کشینگ، اطمینان از به‌روز بودن داده‌های کش‌شده است.
   - **مثال:** اگر داده‌های یک محصول در کش ذخیره شده باشد و قیمت آن تغییر کند، کش باید به‌روزرسانی یا حذف شود.
   - **روش‌ها:** استفاده از TTL (Time-To-Live)، ابطال مبتنی بر رویداد یا Write-Through.
2. **داده‌های قدیمی (Stale Data):**
   - اگر کش به‌درستی ابطال نشود، ممکن است داده‌های قدیمی به کاربران ارائه شود.
   - **مثال:** نمایش موجودی قدیمی یک محصول در یک فروشگاه آنلاین.
3. **مصرف حافظه:** کشینگ داده‌های بزرگ نیاز به حافظه زیادی دارد، که می‌تواند هزینه‌بر باشد.
4. **پیچیدگی سیستم:** مدیریت کش، سیاست‌های ابطال و هماهنگی بین لایه‌ها پیچیدگی را افزایش می‌دهد.
5. **Cache Miss:** اگر داده در کش موجود نباشد، درخواست به منبع اصلی هدایت می‌شود که می‌تواند تأخیر ایجاد کند.

---

## سیاست‌های حذف کش (Cache Eviction Policies)

وقتی حافظه کش پر می‌شود، باید داده‌های قدیمی حذف شوند تا جا برای داده‌های جدید باز شود. سیاست‌های رایج حذف کش عبارتند از:
1. **LRU (Least Recently Used):**
   - داده‌هایی که اخیراً کمترین استفاده را داشته‌اند حذف می‌شوند.
   - **مثال:** Redis از LRU برای حذف داده‌های قدیمی استفاده می‌کند.
2. **LFU (Least Frequently Used):**
   - داده‌هایی که کمترین تعداد دسترسی را داشته‌اند حذف می‌شوند.
   - **مثال:** مناسب برای داده‌هایی که الگوهای دسترسی متغیر دارند.
3. **FIFO (First In, First Out):**
   - داده‌هایی که ابتدا وارد کش شده‌اند حذف می‌شوند.
   - **مثال:** برای داده‌هایی که ترتیب ورود مهم است.
4. **Random:** حذف تصادفی داده‌ها، که ساده اما کمتر کارآمد است.

---

## مثال‌های واقعی از تأثیر کشینگ بر عملکرد

1. **آمازون و DynamoDB Accelerator (DAX):**
   - **سناریو:** آمازون برای سبد خرید و توصیه‌های محصولات از DynamoDB استفاده می‌کند. با افزودن DAX (کش در حافظه)، تأخیر پرس‌وجوها از میلی‌ثانیه به میکروثانیه کاهش یافت.
   - **تأثیر:** در Prime Day 2021، DAX به آمازون کمک کرد تا ۸۹.۲ میلیون درخواست در ثانیه را با تأخیر کم مدیریت کند.
2. **نتفلیکس و CDN (Open Connect):**
   - **سناریو:** نتفلیکس از CDN اختصاصی خود (Open Connect) برای کش کردن ویدئوها در سرورهای لبه استفاده می‌کند.
   - **تأثیر:** کاهش تأخیر پخش ویدئو و صرفه‌جویی در پهنای باند، که امکان پخش همزمان برای میلیون‌ها کاربر را فراهم کرد.
3. **اینستاگرام و Redis:**
   - **سناریو:** اینستاگرام از Redis برای کش کردن فیدهای کاربران و متادیتای پست‌ها استفاده می‌کند.
   - **تأثیر:** کاهش بار روی MongoDB و بهبود زمان بارگذاری فیدها برای میلیاردها کاربر.
4. **وردپرس و WP Super Cache:**
   - **سناریو:** وب‌سایت‌های وردپرسی از افزونه WP Super Cache برای ذخیره‌سازی صفحات HTML رندرشده استفاده می‌کنند.
   - **تأثیر:** کاهش بار روی سرورهای PHP و MySQL، که زمان بارگذاری صفحات را به‌طور قابل توجهی کاهش می‌دهد.

---

## خلاصه و بهترین روش‌ها

### خلاصه
- **کشینگ** با ذخیره‌سازی داده‌های پراستفاده در حافظه سریع، عملکرد، مقیاس‌پذیری و تجربه کاربری را بهبود می‌بخشد.
- **انواع کشینگ:** سمت کاربر (مرورگر)، سمت سرور (Redis، Memcached) و CDN (CloudFront).
- **مزایا:** کاهش تأخیر، افزایش توان عملیاتی، صرفه‌جویی در هزینه‌ها.
- **چالش‌ها:** ابطال کش، داده‌های قدیمی و مصرف حافظه.
- **سیاست‌های حذف:** LRU، LFU و FIFO برای مدیریت حافظه کش استفاده می‌شوند.

### بهترین روش‌ها
1. **انتخاب داده‌های مناسب برای کشینگ:**
   - داده‌های پراستفاده یا پرهزینه (مانند نتایج پرس‌وجوهای پایگاه داده) را کش کنید.
2. **تنظیم TTL مناسب:**
   - از TTL (مانند ۵ دقیقه برای داده‌های پویا) برای جلوگیری از ارائه داده‌های قدیمی استفاده کنید.
3. **استفاده از سیاست‌های ابطال هوشمند:**
   - از مکانیزم‌های مبتنی بر رویداد (مانند ابطال کش هنگام به‌روزرسانی داده) استفاده کنید.
4. **مانیتورینگ Cache Hit Rate:**
   - نرخ موفقیت کش (Cache Hit Rate) را با ابزارهایی مانند Prometheus نظارت کنید تا کارایی کش را ارزیابی کنید.
5. **لایه‌بندی کشینگ:**
   - از ترکیب کش مرورگر، CDN و کش سرور برای بهینه‌سازی عملکرد استفاده کنید.
6. **مدیریت مقیاس‌پذیری:**
   - از ابزارهای توزیع‌شده مانند Redis Cluster یا Memcached برای مقیاس‌پذیری افقی استفاده کنید.
7. **تست و بهینه‌سازی:**
   - تست‌های بار (مانند JMeter) را برای ارزیابی تأثیر کشینگ انجام دهید.

### دیاگرام لایه‌های کشینگ

```
[کاربر]
   |
   v
[CDN (CloudFront)]
   |
   v
[تعادل‌کننده بار]
   |
   v
[سرور برنامه] --> [کش (Redis/Memcached)]
   |
   v
[پایگاه داده (MySQL/DynamoDB)]
```

**توضیح:** درخواست‌های کاربر ابتدا به CDN، سپس به کش سرور و در نهایت به پایگاه داده هدایت می‌شوند تا تأخیر کاهش یابد.

---

## منابع پیشنهادی برای مطالعه بیشتر

1. *Designing Data-Intensive Applications* نوشته مارتین کلپمن: کتابی جامع برای یادگیری کشینگ و طراحی سیستم‌های مقیاس‌پذیر.
2. *The System Design Primer* (منبع متن‌باز در GitHub): راهنمایی برای کشینگ و بهینه‌سازی عملکرد.
3. وبلاگ‌های مهندسی:
   - *AWS Database Blog*: مقالات در مورد DynamoDB DAX و CloudFront.
   - *Netflix Tech Blog*: توضیحات در مورد Open Connect و کشینگ ویدئو.
   - *Redis Blog*: مقالات در مورد استفاده از Redis برای کشینگ.
4. دوره‌های آنلاین:
   - *Grokking the System Design Interview* در DesignGuru.io
   - *System Design Course* در Educative.io
5. مستندات رسمی:
   - [Amazon DynamoDB Accelerator (DAX)](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DAX.html)
   - [Redis Documentation](https://redis.io/documentation)
   - [CloudFront Documentation](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html)

---

این سند مفهوم کشینگ و اهمیت آن در بهبود عملکرد سیستم را به‌صورت جامع توضیح می‌دهد و برای مستندسازی آموزشی و یادگیری طراحی سیستم مناسب است. در صورت نیاز به توضیحات عمیق‌تر یا مثال‌های بیشتر، لطفاً اطلاع دهید!
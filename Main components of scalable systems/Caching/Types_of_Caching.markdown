# انواع کشینگ: کشینگ سمت کاربر، سمت سرور و کش‌های توزیع‌شده (مانند Redis و Memcached)

این سند به بررسی انواع مختلف **کشینگ**، شامل کشینگ سمت کاربر، سمت سرور و توزیع‌شده، با تمرکز بر ابزارهای محبوب مانند **Redis** و **Memcached** می‌پردازد. هدف این است که با ارائه تعاریف، مزایا و محدودیت‌ها، موارد استفاده، مقایسه‌ها، بهترین روش‌ها و مثال‌های واقعی، یک راهنمای جامع و آموزشی برای یادگیری طراحی سیستم فراهم شود. این محتوا به زبان فارسی و با فرمت مارک‌داون ارائه شده است تا برای مستندسازی آموزشی و یادگیری اصول طراحی سیستم مناسب باشد.

---

## مقدمه: نقش کشینگ در طراحی سیستم‌های مدرن

**کشینگ** یکی از تکنیک‌های کلیدی در طراحی سیستم‌های مقیاس‌پذیر است که با ذخیره‌سازی داده‌های پراستفاده در حافظه سریع، عملکرد سیستم را بهبود می‌بخشد، تأخیر را کاهش می‌دهد و مقیاس‌پذیری را افزایش می‌دهد. در سیستم‌های مدرن که با حجم بالای کاربران و داده‌ها سروکار دارند، کشینگ به‌عنوان یک لایه حیاتی در معماری سیستم عمل می‌کند.

**چرا کشینگ مهم است؟**
- **کاهش تأخیر:** دسترسی به داده‌های کش‌شده (مانند RAM یا SSD) سریع‌تر از پایگاه‌های داده یا دیسک است.
- **افزایش مقیاس‌پذیری:** کاهش بار روی سرورهای اصلی امکان پشتیبانی از کاربران بیشتر را فراهم می‌کند.
- **صرفه‌جویی در منابع:** کاهش مصرف CPU، حافظه و شبکه هزینه‌های زیرساختی را کاهش می‌دهد.
- **بهبود تجربه کاربری:** پاسخ‌های سریع‌تر تجربه بهتری برای کاربران فراهم می‌کند.

این سند سه نوع اصلی کشینگ (سمت کاربر، سمت سرور و توزیع‌شده) را بررسی کرده و ابزارهای Redis و Memcached را به‌عنوان نمونه‌های کش توزیع‌شده معرفی می‌کند.

---

## کشینگ سمت کاربر (Client-Side Caching)

### تعریف و مثال‌ها
**کشینگ سمت کاربر** به ذخیره‌سازی داده‌ها در دستگاه کاربر (مانند مرورگر یا برنامه موبایل) اشاره دارد تا درخواست‌های مکرر به سرور کاهش یابد. این نوع کشینگ معمولاً برای محتوای استاتیک یا داده‌هایی که به‌ندرت تغییر می‌کنند استفاده می‌شود.

- **مثال‌ها:**
  - **کش مرورگر (Browser Cache):** ذخیره‌سازی فایل‌های CSS، JavaScript و تصاویر با استفاده از هدرهای HTTP مانند `Cache-Control` و `ETag`.
  - **LocalStorage/SessionStorage:** ذخیره‌سازی داده‌های کوچک (مانند تنظیمات کاربر) در مرورگر.
  - **Service Workers:** برای کش کردن آفلاین صفحات وب در برنامه‌های پیش‌رونده (PWA).

### مزایا
- **کاهش درخواست‌های سرور:** داده‌های استاتیک مستقیماً از دستگاه کاربر بارگذاری می‌شوند.
- **تأخیر کمتر:** دسترسی به داده‌های محلی سریع‌تر از درخواست‌های شبکه است.
- **تجربه آفلاین:** امکان استفاده از برنامه‌ها در حالت آفلاین (مانند Google Docs).

### محدودیت‌ها
- **ظرفیت محدود:** مرورگرها فضای محدودی برای کش دارند (مانند ۵ مگابایت در LocalStorage).
- **عدم کنترل سرور:** سرور کنترل محدودی روی داده‌های کش‌شده در سمت کاربر دارد.
- **چالش ابطال کش:** به‌روزرسانی داده‌های کش‌شده نیاز به تنظیمات پیچیده (مانند versioning فایل‌ها) دارد.
- **امنیت:** داده‌های حساس ممکن است در دستگاه کاربر ذخیره شوند و خطر دسترسی غیرمجاز را افزایش دهند.

---

## کشینگ سمت سرور (Server-Side Caching)

### تعریف و انواع
**کشینگ سمت سرور** به ذخیره‌سازی داده‌ها در سرور یا نزدیک به آن اشاره دارد تا پردازش‌های مکرر یا دسترسی به پایگاه داده کاهش یابد. این نوع کشینگ در لایه‌های مختلف سرور پیاده‌سازی می‌شود.

- **کش در سطح برنامه (Application-Level Cache):**
  - ذخیره‌سازی داده‌ها در حافظه برنامه (مانند Redis یا Memcached) یا حافظه داخلی سرور.
  - **مثال:** ذخیره‌سازی نتایج پرس‌وجوهای پایگاه داده در Redis.
- **پراکسی معکوس (Reverse Proxy Cache):**
  - استفاده از ابزارهایی مانند Varnish یا NGINX برای کش کردن پاسخ‌های HTTP.
  - **مثال:** ذخیره‌سازی صفحات HTML رندرشده در NGINX برای وب‌سایت‌های استاتیک.

### مزایا
- **کنترل بیشتر:** سرور می‌تواند سیاست‌های کشینگ و ابطال را دقیق‌تر مدیریت کند.
- **کاهش بار پایگاه داده:** با ذخیره‌سازی نتایج پرس‌وجوها، فشار روی پایگاه داده کاهش می‌یابد.
- **انعطاف‌پذیری:** مناسب برای داده‌های پویا و استاتیک.
- **عملکرد بالا:** ابزارهایی مانند Varnish پاسخ‌های سریع‌تری نسبت به سرورهای برنامه ارائه می‌دهند.

### چالش‌ها
- **پیچیدگی مدیریت:** نیاز به هماهنگی بین سرور برنامه و کش.
- **مصرف حافظه:** داده‌های بزرگ نیاز به حافظه بیشتری دارند.
- **ابطال کش:** به‌روزرسانی داده‌های کش‌شده در زمان تغییر داده‌ها چالش‌برانگیز است.
- **هزینه زیرساخت:** ابزارهای کش مانند Redis نیاز به سرورهای اختصاصی دارند.

---

## کشینگ توزیع‌شده (Distributed Caching)

### تعریف و موارد استفاده
**کشینگ توزیع‌شده** به استفاده از سیستم‌های کش جداگانه و مقیاس‌پذیر اشاره دارد که بین چندین سرور یا گره توزیع می‌شوند. این نوع کشینگ برای برنامه‌های مقیاس بزرگ و بدون حالت (Stateless) طراحی شده است که نیاز به دسترسی سریع و مقیاس‌پذیری بالا دارند.

- **موارد استفاده:**
  - ذخیره‌سازی داده‌های پراستفاده در برنامه‌های مقیاس بزرگ (مانند شبکه‌های اجتماعی یا تجارت الکترونیک).
  - مدیریت جلسات کاربر (Session Management) در سیستم‌های توزیع‌شده.
  - پردازش بلادرنگ مانند لیدربوردها یا اعلان‌ها.

### مزایا برای سرویس‌های مقیاس‌پذیر و بدون حالت
- **مقیاس‌پذیری افقی:** افزودن گره‌های جدید برای مدیریت بارهای کاری بزرگ.
- **دسترسی‌پذیری بالا:** تکرار داده‌ها بین گره‌ها از تک‌نقطه خرابی جلوگیری می‌کند.
- **عملکرد بالا:** ذخیره‌سازی داده‌ها در حافظه (In-Memory) تأخیر را به میکروثانیه کاهش می‌دهد.
- **انعطاف‌پذیری:** پشتیبانی از معماری‌های میکروسرویس و برنامه‌های توزیع‌شده.

### بررسی Redis
**Redis** یک پایگاه داده در حافظه (In-Memory) و منبع‌باز است که به‌عنوان یک سیستم کش توزیع‌شده و ذخیره‌سازی داده استفاده می‌شود.

- **ویژگی‌ها:**
  - **ذخیره‌سازی در حافظه:** داده‌ها در RAM ذخیره می‌شوند، که دسترسی سریع را فراهم می‌کند.
  - **ساختارهای داده‌ای متنوع:** پشتیبانی از رشته‌ها (Strings)، لیست‌ها، مجموعه‌ها (Sets)، هش‌ها (Hashes)، Sorted Sets و غیره.
  - **پشتیبانی از پایداری (Persistence):** امکان ذخیره‌سازی داده‌ها روی دیسک با RDB یا AOF.
  - **پشتیبانی از Pub/Sub:** برای پیام‌رسانی بلادرنگ.
  - **Redis Cluster:** برای شاردینگ و مقیاس‌پذیری افقی.

- **موارد استفاده:**
  - **مدیریت جلسات (Session Management):** ذخیره‌سازی داده‌های جلسه کاربران در برنامه‌های وب.
  - **لیدربوردها:** مرتب‌سازی سریع امتیازات کاربران در بازی‌ها یا برنامه‌های رقابتی.
  - **پیام‌رسانی بلادرنگ:** استفاده از Pub/Sub برای اعلان‌ها یا چت.
  - **کشینگ نتایج پایگاه داده:** ذخیره‌سازی نتایج پرس‌وجوهای پرتکرار.

- **مثال:** اینستاگرام از Redis برای کش کردن فیدهای کاربران و متادیتای پست‌ها استفاده می‌کند.

### بررسی Memcached
**Memcached** یک سیستم کش توزیع‌شده ساده و منبع‌باز است که برای ذخیره‌سازی داده‌های کلید-مقدار طراحی شده و بر سادگی و سرعت تمرکز دارد.

- **ویژگی‌ها:**
  - **سادگی:** فقط از داده‌های کلید-مقدار پشتیبانی می‌کند، بدون ساختارهای داده‌ای پیچیده.
  - **سرعت بالا:** طراحی شده برای تأخیر کم و توان عملیاتی بالا.
  - **عدم پایداری:** داده‌ها فقط در حافظه ذخیره می‌شوند و در صورت خرابی از بین می‌روند.
  - **مقیاس‌پذیری افقی:** پشتیبانی از توزیع داده‌ها بین گره‌ها.

- **موارد استفاده:**
  - کشینگ نتایج پرس‌وجوهای پایگاه داده در وب‌سایت‌های پرترافیک.
  - ذخیره‌سازی داده‌های موقت مانند نتایج API یا صفحات رندرشده.
  - **مثال:** فیسبوک از Memcached برای کش کردن داده‌های پروفایل کاربران و فیدهای خبری استفاده می‌کند.

- **تفاوت‌ها با Redis:**
  - Memcached ساده‌تر است و فقط از کلید-مقدار پشتیبانی می‌کند، در حالی که Redis ساختارهای داده‌ای متنوعی دارد.
  - Redis از پایداری (Persistence) پشتیبانی می‌کند، اما Memcached خیر.
  - Redis از ویژگی‌های پیشرفته مانند Pub/Sub و Sorted Sets پشتیبانی می‌کند، در حالی که Memcached محدود به عملیات ساده است.

---

## جدول مقایسه: Redis در مقابل Memcached

| **معیار**                | **Redis**                                                                 | **Memcached**                                                             |
|--------------------------|---------------------------------------------------------------------------|---------------------------------------------------------------------------|
| **نوع داده**            | رشته‌ها، لیست‌ها، مجموعه‌ها، هش‌ها، Sorted Sets                          | فقط کلید-مقدار                                                           |
| **پایداری**             | پشتیبانی از RDB و AOF برای ذخیره‌سازی روی دیسک                           | بدون پایداری، داده‌ها در حافظه ذخیره می‌شوند                             |
| **عملکرد**              | بسیار سریع، مناسب برای بارهای کاری پیچیده                               | بسیار سریع، بهینه برای عملیات ساده کلید-مقدار                           |
| **ویژگی‌های پیشرفته**   | Pub/Sub، Lua Scripting، Sorted Sets، Cluster                             | محدود به عملیات ساده کلید-مقدار                                          |
| **مقیاس‌پذیری**         | شاردینگ با Redis Cluster، مقیاس‌پذیری افقی                             | مقیاس‌پذیری افقی با توزیع داده‌ها بین گره‌ها                           |
| **موارد استفاده**       | جلسات، لیدربوردها، پیام‌رسانی بلادرنگ، کشینگ پیچیده                   | کشینگ ساده، نتایج پرس‌وجوهای پایگاه داده، صفحات رندرشده               |
| **پیچیدگی**             | پیچیده‌تر به دلیل ویژگی‌های متنوع                                       | ساده‌تر، مناسب برای استفاده‌های سبک                                      |
| **مثال واقعی**          | اینستاگرام (فید کاربران، متادیتا)                                      | فیسبوک (پروفایل کاربران، فیدهای خبری)                                 |

---

## انتخاب نوع کش مناسب برای نیازهای مختلف سیستم

1. **کشینگ سمت کاربر:**
   - **مناسب برای:** برنامه‌هایی با محتوای استاتیک (مانند تصاویر، CSS، JavaScript) یا برنامه‌های آفلاین (PWA).
   - **مثال سناریو:** یک وب‌سایت خبری که تصاویر و فایل‌های CSS را در مرورگر کاربران کش می‌کند.
   - **ملاحظات:** برای داده‌های حساس، امنیت و ابطال کش را در نظر بگیرید.

2. **کشینگ سمت سرور:**
   - **مناسب برای:** داده‌های پویا مانند نتایج پرس‌وجوهای پایگاه داده یا صفحات رندرشده.
   - **مثال سناریو:** یک وب‌سایت تجارت الکترونیک که نتایج جستجوی محصولات را در Redis ذخیره می‌کند.
   - **ملاحظات:** انتخاب ابزار مناسب (مانند Redis یا Varnish) و مدیریت ابطال کش.

3. **کشینگ توزیع‌شده (Redis/Memcached):**
   - **مناسب برای:** برنامه‌های مقیاس بزرگ، بدون حالت، یا سیستم‌های توزیع‌شده با بار کاری سنگین.
   - **مثال سناریو:** یک شبکه اجتماعی که فید کاربران را در Redis ذخیره می‌کند.
   - **انتخاب بین Redis و Memcached:**
     - **Redis:** برای برنامه‌هایی با نیاز به ساختارهای داده‌ای پیچیده، پایداری یا پیام‌رسانی بلادرنگ.
     - **Memcached:** برای کشینگ ساده با بارهای کاری خواندن/نوشتن سبک.

**عوامل کلیدی در انتخاب:**
- **نوع داده‌ها:** داده‌های استاتیک (کشینگ سمت کاربر)، پویا (کشینگ سمت سرور)، یا پیچیده (کش توزیع‌شده).
- **مقیاس‌پذیری:** برای سیستم‌های بزرگ، کش توزیع‌شده مانند Redis یا Memcached مناسب‌تر است.
- **پیچیدگی:** Memcached برای استفاده‌های ساده و Redis برای ویژگی‌های پیشرفته‌تر مناسب است.
- **هزینه:** کشینگ سمت کاربر کم‌هزینه است، اما کش توزیع‌شده نیاز به زیرساخت اختصاصی دارد.

---

## بهترین روش‌ها برای استفاده از هر نوع کش

### کشینگ سمت کاربر
- **استفاده از هدرهای HTTP:** از `Cache-Control`، `ETag` و `Last-Modified` برای کنترل کش مرورگر استفاده کنید.
- **نسخه‌بندی فایل‌ها:** برای جلوگیری از ارائه داده‌های قدیمی، از نسخه‌بندی (مانند `style-v2.css`) استفاده کنید.
- **امنیت:** داده‌های حساس را در LocalStorage ذخیره نکنید و از HTTPS استفاده کنید.

### کشینگ سمت سرور
- **انتخاب ابزار مناسب:** برای داده‌های پویا از Redis یا Memcached و برای صفحات HTML از Varnish یا NGINX استفاده کنید.
- **تنظیم TTL:** از Time-To-Live مناسب (مانند ۵ دقیقه برای داده‌های پویا) برای جلوگیری از داده‌های قدیمی استفاده کنید.
- **ابطال هوشمند:** از مکانیزم‌های مبتنی بر رویداد (مانند ابطال کش هنگام به‌روزرسانی داده) استفاده کنید.

### کشینگ توزیع‌شده (Redis/Memcached)
- **طراحی کلیدهای کش:** از کلیدهای معنادار و یکنواخت (مانند `user:123:profile`) برای مدیریت آسان استفاده کنید.
- **مقیاس‌پذیری:** از Redis Cluster یا چندین نمونه Memcached برای توزیع بار استفاده کنید.
- **مانیتورینگ:** نرخ موفقیت کش (Cache Hit Rate) را با ابزارهایی مانند Prometheus نظارت کنید.
- **پایداری در Redis:** برای داده‌های حساس، از گزینه‌های پایداری (RDB یا AOF) استفاده کنید.
- **بهینه‌سازی حافظه:** از سیاست‌های حذف کش مانند LRU یا LFU برای مدیریت حافظه استفاده کنید.

---

## خلاصه و مثال‌های واقعی

### خلاصه
- **کشینگ سمت کاربر** برای محتوای استاتیک و کاهش درخواست‌های سرور مناسب است، اما ظرفیت محدود و چالش‌های امنیتی دارد.
- **کشینگ سمت سرور** برای داده‌های پویا و کاهش بار پایگاه داده ایده‌آل است، اما نیاز به مدیریت ابطال دارد.
- **کشینگ توزیع‌شده** برای برنامه‌های مقیاس بزرگ و بدون حالت مناسب است. **Redis** ویژگی‌های پیشرفته‌ای مانند ساختارهای داده‌ای و پایداری ارائه می‌دهد، در حالی که **Memcached** بر سادگی و سرعت تمرکز دارد.
- **درس کلیدی:** انتخاب نوع کش به نوع داده‌ها، نیازهای مقیاس‌پذیری و پیچیدگی سیستم بستگی دارد.

### مثال‌های واقعی
1. **آمازون (کشینگ سمت سرور و توزیع‌شده):**
   - آمازون از DynamoDB Accelerator (DAX) و Redis برای کش کردن داده‌های سبد خرید و توصیه‌های محصولات استفاده می‌کند. در Prime Day 2021، این کش‌ها به مدیریت ۸۹.۲ میلیون درخواست در ثانیه کمک کردند.
2. **اینستاگرام (کشینگ توزیع‌شده با Redis):**
   - اینستاگرام از Redis برای کش کردن فیدهای کاربران و متادیتای پست‌ها استفاده می‌کند، که بار روی MongoDB را کاهش داده و زمان بارگذاری را بهبود می‌بخشد.
3. **فیسبوک (Memcached):**
   - فیسبوک از Memcached برای کش کردن پروفایل‌های کاربران و فیدهای خبری استفاده می‌کند، که به مقیاس‌پذیری برای میلیاردها کاربر کمک کرده است.
4. **وردپرس (کشینگ سمت کاربر و سرور):**
   - وب‌سایت‌های وردپرسی از افزونه‌هایی مانند WP Super Cache برای کش سمت سرور و هدرهای `Cache-Control` برای کش مرورگر استفاده می‌کنند.

---

## منابع پیشنهادی برای مطالعه بیشتر

1. *Designing Data-Intensive Applications* نوشته مارتین کلپمن: کتابی جامع برای یادگیری کشینگ و طراحی سیستم‌های مقیاس‌پذیر.
2. *The System Design Primer* (منبع متن‌باز در GitHub): راهنمایی برای کشینگ و بهینه‌سازی عملکرد.
3. وبلاگ‌های مهندسی:
   - *AWS Database Blog*: مقالات در مورد DynamoDB DAX و CloudFront.
   - *Redis Blog*: مقالات در مورد استفاده از Redis برای کشینگ و پیام‌رسانی.
   - *Facebook Engineering Blog*: توضیحات در مورد استفاده از Memcached در مقیاس بزرگ.
4. دوره‌های آنلاین:
   - *Grokking the System Design Interview* در DesignGuru.io
   - *System Design Course* در Educative.io
5. مستندات رسمی:
   - [Redis Documentation](https://redis.io/documentation)
   - [Memcached Documentation](https://github.com/memcached/memcached/wiki)
   - [NGINX Caching Guide](https://www.nginx.com/resources/wiki/start/topics/examples/cache/)

---

این سند انواع کشینگ و ابزارهای Redis و Memcached را به‌صورت جامع توضیح داده و برای مستندسازی آموزشی و یادگیری طراحی سیستم مناسب است. در صورت نیاز به توضیحات عمیق‌تر یا مثال‌های بیشتر، لطفاً اطلاع دهید!
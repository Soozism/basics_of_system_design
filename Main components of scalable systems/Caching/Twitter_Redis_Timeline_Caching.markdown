# نمونه واقعی: استفاده از Redis در توییتر برای کش کردن تایملاین‌ها

این سند به بررسی استفاده از **Redis** در توییتر برای کش کردن تایملاین‌ها به‌عنوان یک نمونه واقعی از طراحی سیستم‌های مقیاس‌پذیر می‌پردازد. هدف این است که با ارائه توضیحات دقیق در مورد معماری، ساختارهای داده‌ای، مزایا، چالش‌ها و درس‌های آموخته‌شده، یک راهنمای جامع و آموزشی برای یادگیری طراحی سیستم فراهم شود. این محتوا به زبان فارسی و با فرمت مارک‌داون ارائه شده است تا برای مستندسازی آموزشی و یادگیری اصول طراحی سیستم مناسب باشد.

---

## مقدمه: مقیاس توییتر و نیاز به کش کردن تایملاین‌ها

توییتر (اکنون به نام X شناخته می‌شود) یکی از بزرگ‌ترین پلتفرم‌های شبکه‌های اجتماعی است که روزانه با میلیاردها درخواست مواجه می‌شود. طبق آمار سال ۲۰۱۹، توییتر حدود ۱۴۵ میلیون کاربر فعال روزانه و ۵۰۰ میلیون توییت در روز داشته است که معادل حدود ۵۰۰۰ توییت در ثانیه یا ۳۰۰,۰۰۰ درخواست خواندن (QPS) برای تایملاین‌ها است. این حجم عظیم از ترافیک نیازمند سیستمی است که بتواند تایملاین‌های کاربران (شامل توییت‌های ارسالی توسط خود کاربر و افرادی که دنبال می‌کند) را به‌صورت بلادرنگ و با تأخیر کم ارائه دهد.[](https://blog.mi.hdm-stuttgart.de/index.php/2021/03/10/how-to-scale-real-time-tweet-delivery-architecture-at-twitter/)

**چرا کش کردن تایملاین‌ها ضروری است؟**
- **مقیاس‌پذیری:** انجام پرس‌وجوهای پیچیده روی پایگاه داده برای هر درخواست تایملاین (مانند JOIN بین جداول کاربران، توییت‌ها و دنبال‌کنندگان) برای میلیون‌ها کاربر غیرممکن است.
- **تأخیر کم:** کاربران انتظار دارند تایملاین‌ها در کمتر از ۵ ثانیه بارگذاری شوند، حتی در زمان‌های اوج ترافیک (مانند رویدادهای مهم یا توییت‌های سلبریتی‌ها).
- **کاهش بار سرور:** ذخیره‌سازی تایملاین‌های از پیش محاسبه‌شده فشار روی پایگاه‌های داده را کاهش می‌دهد.

توییتر از **Redis**، یک پایگاه داده در حافظه (In-Memory)، برای کش کردن تایملاین‌ها استفاده می‌کند تا عملکرد را بهبود بخشد و تجربه کاربری را بهینه کند.

---

## Redis چیست و چرا برای داده‌های تایملاین مناسب است؟

**Redis** یک پایگاه داده در حافظه، منبع‌باز و با کارایی بالا است که به‌عنوان یک سیستم کش، ذخیره‌ساز داده‌های ساختاریافته و پیام‌رسان استفاده می‌شود. ویژگی‌های کلیدی Redis که آن را برای تایملاین‌های توییتر مناسب می‌کنند عبارتند از:

- **سرعت بالا:** ذخیره‌سازی داده‌ها در RAM دسترسی با تأخیر کم (اغلب در حد میکروثانیه) را فراهم می‌کند.
- **ساختارهای داده‌ای متنوع:** پشتیبانی از لیست‌ها، مجموعه‌های مرتب‌شده (Sorted Sets)، هش‌ها و غیره برای مدیریت داده‌های پیچیده.
- **مقیاس‌پذیری:** قابلیت استفاده از Redis Cluster برای شاردینگ و توزیع داده‌ها بین گره‌ها.
- **سادگی و انعطاف‌پذیری:** امکان انجام عملیات در حافظه بدون نیاز به پرس‌وجوهای پیچیده پایگاه داده.

**چرا برای تایملاین‌ها مناسب است؟**
- تایملاین‌ها (مانند Home Timeline و User Timeline) شامل لیست‌های مرتب‌شده‌ای از شناسه‌های توییت (Tweet IDs) هستند که نیاز به دسترسی سریع و مرتب‌سازی زمانی دارند.
- Redis با استفاده از ساختارهای داده‌ای مانند لیست‌ها و مجموعه‌های مرتب‌شده، این نیاز را به‌خوبی برآورده می‌کند.
- توییتر از نسخه سفارشی‌شده‌ای از Redis به نام **Haplo** استفاده می‌کند که شامل ساختارهای داده‌ای اختصاصی مانند **Hybrid List** (ترکیبی از Ziplist و Linked List) و BTree است.[](https://www.algonote.com/entry/twitter-timeline-cache)

---

## چگونه توییتر از Redis برای کش کردن تایملاین‌ها استفاده می‌کند؟

توییتر از Redis برای ذخیره‌سازی و مدیریت تایملاین‌ها به روش‌های زیر استفاده می‌کند:

### ۱. ذخیره‌سازی تایملاین‌های از پیش محاسبه‌شده
- **تایملاین خانگی (Home Timeline):** لیستی از توییت‌های ارسالی توسط کاربر و افرادی که دنبال می‌کند، به‌ترتیب زمانی معکوس. این تایملاین به‌صورت پیش‌محاسبه‌شده در Redis ذخیره می‌شود تا از پرس‌وجوهای پیچیده در زمان خواندن جلوگیری شود.
- **تایملاین کاربر (User Timeline):** شامل توییت‌های ارسالی توسط یک کاربر خاص. این تایملاین نیز در Redis ذخیره می‌شود.
- **روش Fanout-on-Write:** وقتی کاربری توییتی ارسال می‌کند، سرویس Fanout توییتر (با استفاده از daemon) لیست دنبال‌کنندگان کاربر را از سرویس گراف اجتماعی (Flock) دریافت کرده و شناسه توییت را به تایملاین خانگی هر دنبال‌کننده در Redis اضافه می‌کند. این روش باعث می‌شود خواندن تایملاین سریع باشد، اما نوشتن (به‌ویژه برای کاربران با دنبال‌کنندگان زیاد) سنگین است.[](https://blogs.vmware.com/tanzu/case-study-staple-yourself-to-a-tweet-to-understand-30-billion-redis-updates-per-day/)
- **ذخیره‌سازی محدود:** Redis فقط ۸۰۰ شناسه توییت اخیر را برای هر تایملاین ذخیره می‌کند، که بهینه‌سازی مصرف حافظه را ممکن می‌سازد.[](https://highscalability.com/the-architecture-twitter-uses-to-deal-with-150m-active-users/)

### ۲. بهبود عملکرد و کاهش تأخیر
- **دسترسی در حافظه:** با ذخیره‌سازی تایملاین‌ها در RAM، توییتر می‌تواند به ۳۰۰,۰۰۰ درخواست در ثانیه (QPS) برای تایملاین‌ها پاسخ دهد.[](https://blog.mi.hdm-stuttgart.de/index.php/2021/03/10/how-to-scale-real-time-tweet-delivery-architecture-at-twitter/)
- **ساختارهای داده‌ای بهینه:** استفاده از **Hybrid List** (ترکیبی از Ziplist برای توییت‌های کوچک و Linked List برای دسترسی سریع) عملیات افزودن و خواندن را سریع‌تر می‌کند.[](https://www.algonote.com/entry/twitter-timeline-cache)
- **پردازش بلادرنگ:** Redis امکان افزودن توییت‌های جدید به تایملاین‌ها را در کمتر از ۵ ثانیه فراهم می‌کند، حتی در زمان‌های اوج ترافیک (مانند توییت‌های سلبریتی‌ها).[](https://blog.mi.hdm-stuttgart.de/index.php/2021/03/10/how-to-scale-real-time-tweet-delivery-architecture-at-twitter/)

### ۳. کاهش فشار روی سرویس‌های backend و پایگاه‌های داده
- **کاهش پرس‌وجوهای پایگاه داده:** بدون کشینگ، هر درخواست تایملاین نیاز به JOINهای پیچیده بین جداول کاربران، توییت‌ها و دنبال‌کنندگان در پایگاه داده (مانند MySQL یا Cassandra) دارد، که مقیاس‌پذیر نیست.[](https://elatov.github.io/2021/01/distributed-systems-design-twitter/)
- **ذخیره‌سازی فعالان:** Redis فقط تایملاین‌های کاربران فعال (کسانی که در ۳۰ روز گذشته وارد سیستم شده‌اند) را در حافظه نگه می‌دارد. برای کاربران غیرفعال، تایملاین‌ها از دیسک (MySQL با Gizzard) بازسازی می‌شوند.[](https://highscalability.com/the-architecture-twitter-uses-to-deal-with-150m-active-users/)
- **تکرار داده‌ها:** تایملاین‌ها در Redis به‌صورت سه‌تایی در دیتاسنترهای مختلف تکرار می‌شوند تا از دسترس‌پذیری بالا و تحمل خطا اطمینان حاصل شود.[](https://blog.mi.hdm-stuttgart.de/index.php/2021/03/10/how-to-scale-real-time-tweet-delivery-architecture-at-twitter/)

---

## ساختارهای داده‌ای Redis که برای تایملاین‌ها مفید هستند

توییتر از ساختارهای داده‌ای زیر در Redis برای مدیریت تایملاین‌ها استفاده می‌کند:

1. **لیست‌ها (Lists):**
   - برای ذخیره‌سازی تایملاین‌ها به‌صورت لیست‌های مرتب‌شده از شناسه‌های توییت (Tweet IDs).
   - دستورات مانند `LPUSH` برای افزودن توییت جدید به ابتدای لیست و `LRANGE` برای بازیابی محدوده‌ای از توییت‌ها استفاده می‌شوند.[](https://scalegrid.io/blog/caching-tweets-using-node-js-redis-and-socket-io-2/)
   - **Hybrid List:** ترکیبی از Ziplist (برای توییت‌های کوچک و بهینه‌سازی حافظه) و Linked List (برای دسترسی سریع) که توسط توییتر در Haplo پیاده‌سازی شده است.[](https://www.algonote.com/entry/twitter-timeline-cache)

2. **مجموعه‌های مرتب‌شده (Sorted Sets):**
   - برای ذخیره‌سازی تایملاین‌ها با امتیاز زمانی (Timestamp) برای مرتب‌سازی معکوس زمانی.
   - دستور `ZREVRANGE` برای بازیابی توییت‌های اخیر و `ZADD` برای افزودن توییت جدید استفاده می‌شود.[](https://redis.com/ebook/part-2-core-concepts/chapter-8-building-a-simple-social-network/8-2-home-timeline/)
   - مناسب برای اعمال قوانین تجاری (مانند حذف پاسخ‌های @ از کاربرانی که دنبال نمی‌شوند).

3. **هش‌ها (Hashes):**
   - برای ذخیره‌سازی جزئیات توییت‌ها (مانند متن، کاربر، زمان) در کنار شناسه‌ها.
   - در توییتر، جزئیات توییت از سیستم‌های دیگر (مانند Gizmoduck برای اطلاعات کاربر و TweetyPie برای توییت‌ها) بازیابی می‌شود، اما Redis می‌تواند متادیتا را ذخیره کند.[](https://blogs.vmware.com/tanzu/case-study-staple-yourself-to-a-tweet-to-understand-30-billion-redis-updates-per-day/)

---

## چگونه کش کردن تایملاین‌ها تجربه کاربری را بهبود می‌بخشد؟

- **بارگذاری سریع:** تایملاین‌های ذخیره‌شده در Redis امکان بارگذاری در کمتر از ۵ ثانیه را فراهم می‌کنند، حتی در زمان‌های اوج ترافیک.[](https://highscalability.com/the-architecture-twitter-uses-to-deal-with-150m-active-users/)
- **دسترسی بلادرنگ:** کاربران می‌توانند توییت‌های جدید را تقریباً بلافاصله پس از ارسال ببینند، که برای پلتفرم‌های اجتماعی حیاتی است.
- **کاهش بار دستگاه کاربر:** با پیش‌محاسبه تایملاین‌ها در Redis، دستگاه کاربر (موبایل یا وب) فقط نیاز به دریافت لیست آماده دارد، که پردازش محلی را کاهش می‌دهد.[](https://blog.mi.hdm-stuttgart.de/index.php/2021/03/10/how-to-scale-real-time-tweet-delivery-architecture-at-twitter/)
- **تجربه یکپارچه:** قوانین تجاری (مانند حذف پاسخ‌های غیرمرتبط یا نمایش ریتوییت‌ها) در زمان نوشتن اعمال می‌شوند، که تجربه‌ای منسجم برای کاربر ایجاد می‌کند.[](https://blogs.vmware.com/tanzu/case-study-staple-yourself-to-a-tweet-to-understand-30-billion-redis-updates-per-day/)

---

## چالش‌های توییتر در استفاده از Redis برای تایملاین‌ها

1. **ابطال کش (Cache Invalidation):**
   - وقتی توییتی حذف یا ویرایش می‌شود، تمام تایملاین‌های مرتبط (برای همه دنبال‌کنندگان) باید به‌روزرسانی شوند.
   - برای کاربران با دنبال‌کنندگان زیاد (مانند سلبریتی‌ها)، این فرآیند می‌تواند میلیون‌ها کلید Redis را تحت تأثیر قرار دهد، که سنگین است.[](https://www.algonote.com/entry/twitter-timeline-cache)

2. **سازگاری داده‌ها (Consistency):**
   - توییتر از مدل **سازگاری نهایی (Eventual Consistency)** استفاده می‌کند، به این معنی که ممکن است توییت‌ها با تأخیر جزئی نمایش داده شوند.[](https://medium.com/%40narengowda/system-design-for-twitter-e737284afc95)
   - اگر داده‌های کش خراب شوند یا بخشی از لیست گم شود، تشخیص آن دشوار است.[](https://www.linkedin.com/pulse/how-twitter-uses-redis-scale-105tb-ram-39mm-qps-10000-iravani)

3. **مدیریت کلیدهای داغ (Hotkeys):**
   - تایملاین‌های کاربران پرطرفدار (مانند سلبریتی‌ها) به دلیل دسترسی‌های مکرر می‌توانند بار سنگینی روی سرورهای Redis ایجاد کنند.
   - توییتر از **Nighthawk** (لایه API برای تبدیل درخواست‌های Thrift به دستورات Redis) برای شناسایی و کش کردن محلی کلیدهای داغ استفاده می‌کند.[](https://matthewtejo.substack.com/p/handling-hotkeys-in-timeline-storage)

4. **محدودیت حافظه:**
   - تایملاین‌های بزرگ (مانند تایملاین‌های سلبریتی‌ها) نیاز به تخصیص حافظه مداوم دارند، که می‌تواند باعث حذف تایملاین‌های کوچک‌تر شود.[](https://www.algonote.com/entry/twitter-timeline-cache)
   - Redis از استراتژی **LRU (Least Recently Used)** برای حذف داده‌ها استفاده می‌کند، که ممکن است تایملاین‌های غیرفعال را حذف کند.[](https://elatov.github.io/2021/01/distributed-systems-design-twitter/)

---

## استراتژی‌های توییتر برای به‌روز نگه داشتن تایملاین‌ها

1. **Fanout-on-Write برای کاربران فعال:**
   - توییتر توییت‌های جدید را به‌طور مستقیم به تایملاین‌های کاربران فعال در Redis اضافه می‌کند. کاربران فعال کسانی هستند که در ۳۰ روز گذشته وارد سیستم شده‌اند.[](https://highscalability.com/the-architecture-twitter-uses-to-deal-with-150m-active-users/)
   - این روش خواندن را سریع می‌کند، اما نوشتن را سنگین می‌کند.

2. **بازسازی تایملاین برای کاربران غیرفعال:**
   - برای کاربران غیرفعال، تایملاین‌ها در Redis ذخیره نمی‌شوند. در عوض، با ورود کاربر، تایملاین از دیسک (MySQL با Gizzard) بازسازی شده و به Redis منتقل می‌شود. این فرآیند حدود ۳ ثانیه طول می‌کشد.[](https://blog.mi.hdm-stuttgart.de/index.php/2021/03/10/how-to-scale-real-time-tweet-delivery-architecture-at-twitter/)

3. **مدیریت کلیدهای داغ:**
   - توییتر از Nighthawk برای شناسایی کلیدهای داغ (مانند تایملاین‌های سلبریتی‌ها) و کش کردن محلی آن‌ها در لایه API استفاده می‌کند تا فشار روی سرورهای Redis کاهش یابد.[](https://matthewtejo.substack.com/p/handling-hotkeys-in-timeline-storage)

4. **بهینه‌سازی برای سلبریتی‌ها:**
   - برای کاربران با دنبال‌کنندگان زیاد، توییتر از رویکرد ترکیبی استفاده می‌کند: توییت‌های سلبریتی‌ها ممکن است در زمان خواندن (Read-Time Merge) به تایملاین‌ها اضافه شوند تا از نوشتن سنگین در میلیون‌ها تایملاین جلوگیری شود.[](https://www.stackbit.com/blog/build-twitter-timeline-today-1)

5. **استفاده از Kafka برای پردازش رویدادها:**
   - توییتر از Apache Kafka برای ارسال رویدادهای توییت به سرویس پردازش توییت استفاده می‌کند، که تایملاین‌ها را به‌صورت غیرهمزمان به‌روزرسانی می‌کند.[](https://medium.com/%40lazygeek78/design-of-x-twitter-7233483b5d31)

6. **تکرار و شاردینگ:**
   - تایملاین‌ها در سه نسخه در دیتاسنترهای مختلف تکرار می‌شوند تا تحمل خطا افزایش یابد.
   - از شاردینگ مبتنی بر **Consistent Hashing** برای توزیع داده‌ها بین گره‌های Redis استفاده می‌شود.[](https://elatov.github.io/2021/01/distributed-systems-design-twitter/)

---

## درس‌های آموخته‌شده: چرا Redis ابزار قدرتمندی برای تحویل محتوای بلادرنگ است؟

1. **سرعت بی‌نظیر:**
   - ذخیره‌سازی در حافظه و استفاده از ساختارهای داده‌ای بهینه (مانند Hybrid List) امکان پاسخ‌دهی در میکروثانیه را فراهم می‌کند.
2. **انعطاف‌پذیری ساختارهای داده‌ای:**
   - پشتیبانی از لیست‌ها، مجموعه‌های مرتب‌شده و هش‌ها Redis را برای مدیریت تایملاین‌های پیچیده مناسب می‌کند.
3. **مقیاس‌پذیری افقی:**
   - Redis Cluster و شاردینگ امکان مدیریت میلیاردها درخواست روزانه را فراهم می‌کنند.
4. **مدیریت کلیدهای داغ:**
   - قابلیت‌های سفارشی‌سازی (مانند Haplo و Nighthawk) به توییتر کمک کرده تا با چالش‌های مقیاس بزرگ کنار بیاید.
5. **کاهش بار پایگاه داده:**
   - با پیش‌محاسبه تایملاین‌ها، Redis فشار روی MySQL و Cassandra را به‌طور قابل‌توجهی کاهش می‌دهد.

**مثال واقعی:** در سال ۲۰۱۴، توییتر گزارش داد که Redis با ۱۰۵ ترابایت RAM و بیش از ۱۰,۰۰۰ نمونه، ۳۹ میلیون QPS را مدیریت می‌کند، که تایملاین‌ها بخش عمده‌ای از این بار را تشکیل می‌دهند.[](https://www.linkedin.com/pulse/how-twitter-uses-redis-scale-105tb-ram-39mm-qps-10000-iravani)

---

## خلاصه بینش‌های معماری

- **معماری Fanout-on-Write:** توییتر با پیش‌محاسبه تایملاین‌ها در Redis، خواندن را سریع و نوشتن را سنگین می‌کند، که برای سیستم‌های خواندن-سنگین (Read-Heavy) مانند توییتر مناسب است.
- **ساختارهای داده‌ای بهینه:** استفاده از Hybrid List و Sorted Sets به توییتر امکان می‌دهد تایملاین‌ها را به‌صورت کارآمد ذخیره و بازیابی کند.
- **مدیریت کاربران فعال و غیرفعال:** ذخیره‌سازی تایملاین‌های کاربران فعال در RAM و بازسازی تایملاین‌های کاربران غیرفعال از دیسک، تعادل بین عملکرد و مصرف حافظه را برقرار می‌کند.
- **تحمل خطا و مقیاس‌پذیری:** تکرار داده‌ها و شاردینگ مبتنی بر Consistent Hashing از خرابی‌ها جلوگیری کرده و مقیاس‌پذیری را تضمین می‌کند.
- **چالش‌های مقیاس:** مدیریت کلیدهای داغ و ابطال کش برای کاربران پرطرفدار نیاز به راهکارهای پیشرفته‌ای مانند Nighthawk دارد.

---

## دیاگرام جریان داده‌ها

```
[کاربر]
   |
   v
[API توییتر]
   | (درخواست تایملاین)
   v
[Redis Cluster (Haplo)]
   | (Cache Hit: تایملاین از پیش محاسبه‌شده)
   | (Cache Miss: بازسازی تایملاین)
   v
[سرویس گراف اجتماعی (Flock)] <--> [پایگاه داده دیسک: MySQL/Cassandra]
   | (دریافت لیست دنبال‌کنندگان)
   v
[سرویس پردازش توییت] <--> [Kafka: رویدادهای توییت]
   | (به‌روزرسانی تایملاین‌ها)
   v
[Redis Cluster: ذخیره‌سازی تایملاین به‌روز]
   |
   v
[کاربر: نمایش تایملاین]
```

**توضیح دیاگرام:**
1. کاربر درخواست تایملاین می‌دهد.
2. API توییتر ابتدا Redis (Haplo) را بررسی می‌کند.
3. در صورت Cache Hit، تایملاین از Redis بازمی‌گردد.
4. در صورت Cache Miss (کاربر غیرفعال)، سرویس گراف اجتماعی (Flock) لیست دنبال‌کنندگان را از پایگاه داده دریافت کرده و تایملاین بازسازی می‌شود.
5. توییت‌های جدید از طریق Kafka پردازش شده و تایملاین‌ها در Redis به‌روزرسانی می‌شوند.
6. تایملاین به کاربر نمایش داده می‌شود.

---

## منابع پیشنهادی برای مطالعه بیشتر

1. *Designing Data-Intensive Applications* نوشته مارتین کلپمن: کتابی جامع برای یادگیری کشینگ و طراحی سیستم‌های مقیاس‌پذیر.
2. *The System Design Primer* (منبع متن‌باز در GitHub): راهنمایی برای کشینگ و بهینه‌سازی عملکرد.
3. وبلاگ‌ها و ارائه‌ها:
   - *Scaling Redis at Twitter* توسط Yao Yue (2014): توضیحات عمیق در مورد استفاده از Redis در توییتر.[](https://highscalability.com/how-twitter-uses-redis-to-scale-105tb-ram-39mm-qps-10000-ins/)
   - *The Infrastructure Behind Twitter* (High Scalability, 2013): جزئیات معماری توییتر.[](https://highscalability.com/the-architecture-twitter-uses-to-deal-with-150m-active-users/)
   - *Redis Documentation: Home Timeline* (redis.com): مثال‌های کد برای تایملاین‌ها.[](https://redis.com/ebook/part-2-core-concepts/chapter-8-building-a-simple-social-network/8-2-home-timeline/)
4. مستندات رسمی:
   - [Redis Documentation](https://redis.io/documentation)
   - [Twitter Engineering Blog](https://blog.twitter.com/engineering)
5. دوره‌های آنلاین:
   - *Grokking the System Design Interview* در DesignGuru.io
   - *System Design Course* در Educative.io

---

این سند استفاده از Redis در توییتر برای کش کردن تایملاین‌ها را به‌صورت جامع توضیح داده و برای مستندسازی آموزشی و یادگیری طراحی سیستم مناسب است. در صورت نیاز به توضیحات عمیق‌تر یا مثال‌های بیشتر، لطفاً اطلاع دهید!
<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>معماری‌های مبتنی بر رویداد (Event-Driven Architectures)</title>
    <link rel="stylesheet" href="../../css/style.css">
    <meta name="description" content="معماری‌های مبتنی بر رویداد (Event-Driven Architectures)">
    <meta name="keywords" content="طراحی سیستم, مهندسی نرم‌افزار, معماری سیستم">
</head>
<body>
    <header>
        <div class="header-content">
            <a href="../../index.html" class="logo">طراحی سیستم</a>
            <nav>
                <ul class="nav-menu">
                    <li><a href="../../index.html">خانه</a></li>
                    <li><a href="../../index.html#basic-concepts">مفاهیم پایه</a></li>
                    <li><a href="../../index.html#main-components">اجزای اصلی</a></li>
                    <li><a href="../../index.html#scalable-systems">سیستم‌های مقیاس‌پذیر</a></li>
                    <li><a href="../../index.html#advanced-topics">موضوعات پیشرفته</a></li>
                    <li><a href="../../index.html#interviews">مصاحبه</a></li>
                </ul>
            </nav>
            <button class="mobile-menu-toggle">☰</button>
        </div>
    </header>

    <div class="container">
        <main class="main-content">
            <aside class="sidebar">
                
    <h3>معماری‌های مبتنی بر رویداد (Event-Driven Architectures)</h3>
    <ul>
        <li><a href="../../../index.html">بازگشت به خانه</a></li>
        <li><a href="../../../index.html#basic-concepts">مفاهیم پایه</a></li>
        <li><a href="../../../index.html#main-components">اجزای اصلی</a></li>
        <li><a href="../../../index.html#scalable-systems">سیستم‌های مقیاس‌پذیر</a></li>
        <li><a href="../../../index.html#advanced-topics">موضوعات پیشرفته</a></li>
        <li><a href="../../../index.html#interviews">آمادگی مصاحبه</a></li>
    </ul>
    
            </aside>

            <article class="content">
                <div class="breadcrumb">
                    <a href="index.html">خانه</a>
<span>/</span>
<span>Main components of scalable systems</span>
<span>/</span>
<span>Messaging and Queues</span>
<span>/</span>
<span>Event_Driven_Architectures.html</span>
                </div>

                <h1>معماری‌های مبتنی بر رویداد (Event-Driven Architectures)</h1>

<p>این سند به بررسی مفهوم <strong>معماری‌های مبتنی بر رویداد (Event-Driven Architectures یا EDA)</strong> در طراحی سیستم‌های مقیاس‌پذیر می‌پردازد. هدف این است که با ارائه تعاریف، اجزای اصلی، انواع مدل‌ها، مزایا و معایب، موارد استفاده واقعی، راهنمایی برای انتخاب و بهترین روش‌ها، یک راهنمای جامع و آموزشی برای یادگیری طراحی سیستم فراهم شود. این محتوا به زبان فارسی و با فرمت مارک‌داون ارائه شده است تا برای مستندسازی آموزشی و یادگیری اصول طراحی سیستم مناسب باشد.</p>

<p>---</p>

<h2>مقدمه: معماری مبتنی بر رویداد چیست و چرا اهمیت دارد؟</h2>

<strong>معماری مبتنی بر رویداد (EDA)</strong> رویکردی در طراحی سیستم است که در آن سرویس‌ها یا اجزای سیستم از طریق تولید، انتشار و پردازش <strong>رویدادها (Events)</strong> با یکدیگر ارتباط برقرار می‌کنند. رویدادها نشان‌دهنده تغییرات یا وقایع مهم در سیستم هستند (مانند ثبت یک سفارش یا ورود کاربر) و به‌صورت ناهمزمان (Asynchronous) پردازش می‌شوند. این معماری در سیستم‌های توزیع‌شده و میکروسرویس‌ها محبوب است، زیرا امکان جداسازی سرویس‌ها، مقیاس‌پذیری و پاسخگویی بلادرنگ را فراهم می‌کند.

<strong>چرا EDA در سیستم‌های مقیاس‌پذیر مهم است؟</strong>
<ul><li><strong>پاسخگویی بلادرنگ:</strong> EDA امکان واکنش سریع به تغییرات (مانند اعلان‌های کاربر یا تحلیل داده‌ها) را فراهم می‌کند.</li></ul>
<ul><li><strong>مقیاس‌پذیری:</strong> با جداسازی تولیدکنندگان و مصرف‌کنندگان رویداد، سیستم می‌تواند بارهای کاری سنگین را مدیریت کند.</li></ul>
<ul><li><strong>انعطاف‌پذیری:</strong> سرویس‌ها می‌توانند به‌صورت مستقل توسعه، مستقر و مقیاس‌بندی شوند.</li></ul>
<ul><li><strong>تاب‌آوری:</strong> خرابی یک سرویس تأثیری بر کل سیستم ندارد، زیرا رویدادها در صف‌ها یا لاگ‌ها ذخیره می‌شوند.</li></ul>

<p>این سند اجزای اصلی، مدل‌ها، مزایا، چالش‌ها و موارد استفاده EDA را بررسی کرده و راهنمایی برای طراحی سیستم‌های مبتنی بر رویداد ارائه می‌دهد.</p>

<p>---</p>

<h2>اجزای اصلی معماری مبتنی بر رویداد</h2>

<h3>۱. رویدادها (Events)</h3>
<ul><li><strong>تعریف:</strong> رویداد یک پیام یا داده است که نشان‌دهنده وقوع یک تغییر یا عمل در سیستم است (مانند «کاربر ثبت‌نام کرد» یا «سفارش تأیید شد»).</li></ul>
<ul><li><strong>ویژگی‌ها:</strong></li></ul>
  - <strong>ساختار:</strong> معمولاً شامل شناسه رویداد، نوع رویداد، زمان وقوع و داده‌های مرتبط است.
  - <strong>ناهمزمان:</strong> رویدادها به‌صورت ناهمزمان منتشر و پردازش می‌شوند.
  - <strong>مثال:</strong> <code>{ "event_id": "123", "type": "OrderPlaced", "timestamp": "2025-07-11T22:12:00Z", "data": { "order_id": "456", "user_id": "789" } }</code>

<h3>۲. تولیدکنندگان (Producers)</h3>
<ul><li><strong>تعریف:</strong> سرویس‌ها یا برنامه‌هایی که رویدادها را تولید و به سیستم پیام‌رسانی ارسال می‌کنند.</li></ul>
<ul><li><strong>وظایف:</strong> تشخیص تغییرات در سیستم و ایجاد پیام‌های رویداد.</li></ul>
<ul><li><strong>مثال:</strong> یک سرویس سفارش در یک پلتفرم تجارت الکترونیک رویداد «OrderPlaced» را تولید می‌کند.</li></ul>

<h3>۳. مصرف‌کنندگان (Consumers)</h3>
<ul><li><strong>تعریف:</strong> سرویس‌ها یا برنامه‌هایی که رویدادها را از سیستم پیام‌رسانی دریافت و پردازش می‌کنند.</li></ul>
<ul><li><strong>وظایف:</strong> واکنش به رویدادها، مانند به‌روزرسانی پایگاه داده، ارسال اعلان یا تحلیل داده‌ها.</li></ul>
<ul><li><strong>مثال:</strong> یک سرویس اعلان که پس از دریافت رویداد «OrderPlaced» ایمیلی به کاربر ارسال می‌کند.</li></ul>

<h3>۴. کارگزاران رویداد (Event Brokers)</h3>
<ul><li><strong>تعریف:</strong> سیستم‌هایی که رویدادها را از تولیدکنندگان دریافت، ذخیره و به مصرف‌کنندگان تحویل می‌دهند.</li></ul>
<ul><li><strong>ابزارهای رایج:</strong></li></ul>
  - <strong>Apache Kafka:</strong> برای پردازش جریان‌های داده‌ای بزرگ‌مقیاس.
  - <strong>RabbitMQ:</strong> برای پیام‌رسانی مبتنی بر AMQP با مسیریابی پیشرفته.
  - <strong>AWS EventBridge:</strong> سرویس مدیریت‌شده برای رویدادها در اکوسیستم AWS.
<ul><li><strong>ویژگی‌ها:</strong> ذخیره‌سازی موقت رویدادها، تضمین تحویل و پشتیبانی از مقیاس‌پذیری.</li></ul>

<p>---</p>

<h2>انواع مدل‌های معماری مبتنی بر رویداد</h2>

<h3>۱. مدل انتشار/اشتراک (Publish/Subscribe)</h3>
<ul><li><strong>توضیح:</strong> تولیدکنندگان رویدادها را به یک موضوع (Topic) منتشر می‌کنند و مصرف‌کنندگان به موضوعات موردنظر اشتراک می‌کنند.</li></ul>
<ul><li><strong>ویژگی‌ها:</strong></li></ul>
  - چندین مصرف‌کننده می‌توانند به یک رویداد واکنش نشان دهند.
  - مناسب برای سناریوهایی که نیاز به اطلاع‌رسانی گسترده دارند.
<ul><li><strong>مثال:</strong> در یک اپلیکیشن شبکه اجتماعی، رویداد «PostCreated» به تمام دنبال‌کنندگان کاربر منتشر می‌شود.</li></ul>
<ul><li><strong>ابزارها:</strong> Kafka، RabbitMQ (با Fanout Exchange)، AWS SNS.</li></ul>

<h3>۲. پردازش جریان رویداد (Event Stream Processing)</h3>
<ul><li><strong>توضیح:</strong> پردازش بلادرنگ یا نزدیک به بلادرنگ جریان‌های مداوم رویدادها برای تحلیل یا واکنش.</li></ul>
<ul><li><strong>ویژگی‌ها:</strong></li></ul>
  - مناسب برای تحلیل داده‌های بزرگ‌مقیاس یا تشخیص الگوها.
  - اغلب با ابزارهایی مانند Kafka Streams یا Apache Flink پیاده‌سازی می‌شود.
<ul><li><strong>مثال:</strong> تحلیل بلادرنگ کلیک‌های کاربران برای تشخیص تقلب در یک پلتفرم تبلیغاتی.</li></ul>
<ul><li><strong>ابزارها:</strong> Kafka Streams، AWS Kinesis، Apache Spark Streaming.</li></ul>

<h3>۳. منبع‌یابی رویداد (Event Sourcing)</h3>
<ul><li><strong>توضیح:</strong> به‌جای ذخیره حالت فعلی سیستم، تمام رویدادهایی که منجر به تغییرات حالت شده‌اند ذخیره می‌شوند.</li></ul>
<ul><li><strong>ویژگی‌ها:</strong></li></ul>
  - امکان بازسازی حالت سیستم با بازپخش رویدادها.
  - مناسب برای سیستم‌هایی که نیاز به تاریخچه کامل تغییرات دارند.
<ul><li><strong>مثال:</strong> در یک سیستم بانکی، رویدادهای «Deposit» و «Withdrawal» برای بازسازی موجودی حساب ذخیره می‌شوند.</li></ul>
<ul><li><strong>ابزارها:</strong> Kafka، EventStoreDB، MongoDB.</li></ul>

<p>---</p>

<h2>مزایای معماری مبتنی بر رویداد</h2>

<h3>۱. جداسازی (Loose Coupling)</h3>
<ul><li><strong>توضیح:</strong> تولیدکنندگان و مصرف‌کنندگان از طریق کارگزار رویداد ارتباط برقرار می‌کنند و نیازی به دانش مستقیم از یکدیگر ندارند.</li></ul>
<ul><li><strong>مزیت:</strong> سرویس‌ها می‌توانند به‌صورت مستقل توسعه و مستقر شوند.</li></ul>
<ul><li><strong>مثال:</strong> در یک سیستم تجارت الکترونیک، سرویس سفارش نیازی به دانستن جزئیات سرویس انبارداری ندارد.</li></ul>

<h3>۲. مقیاس‌پذیری</h3>
<ul><li><strong>توضیح:</strong> مصرف‌کنندگان می‌توانند به‌صورت موازی رویدادها را پردازش کنند، و کارگزاران رویداد مانند Kafka از مقیاس‌پذیری افقی پشتیبانی می‌کنند.</li></ul>
<ul><li><strong>مزیت:</strong> سیستم می‌تواند بارهای کاری سنگین (مانند میلیون‌ها رویداد در ثانیه) را مدیریت کند.</li></ul>
<ul><li><strong>مثال:</strong> توییتر از Kafka برای پردازش رویدادهای توییت در مقیاس بزرگ استفاده می‌کند.</li></ul>

<h3>۳. پاسخگویی بلادرنگ</h3>
<ul><li><strong>توضیح:</strong> رویدادها به‌سرعت منتشر و پردازش می‌شوند، که امکان واکنش بلادرنگ را فراهم می‌کند.</li></ul>
<ul><li><strong>مزیت:</strong> مناسب برای برنامه‌هایی که نیاز به اعلان‌های فوری یا تحلیل داده‌های زنده دارند.</li></ul>
<ul><li><strong>مثال:</strong> اپلیکیشن‌های چت مانند WhatsApp از EDA برای ارسال پیام‌های بلادرنگ استفاده می‌کنند.</li></ul>

<p>---</p>

<h2>چالش‌های معماری مبتنی بر رویداد</h2>

<h3>۱. ترتیب رویدادها (Event Ordering)</h3>
<ul><li><strong>چالش:</strong> تضمین ترتیب صحیح پردازش رویدادها در سیستم‌های توزیع‌شده دشوار است، به‌ویژه وقتی چندین مصرف‌کننده وجود دارد.</li></ul>
<ul><li><strong>مثال:</strong> در یک سیستم بانکی، اگر رویداد «Withdrawal» قبل از «Deposit» پردازش شود، ممکن است موجودی نادرست شود.</li></ul>
<ul><li><strong>راه‌حل:</strong> استفاده از پارتیشن‌های Kafka یا صف‌های FIFO در SQS برای حفظ ترتیب در هر کلید.</li></ul>

<h3>۲. مدیریت خطاها و تلاش مجدد (Handling Failures and Retries)</h3>
<ul><li><strong>چالش:</strong> اگر مصرف‌کننده در پردازش یک رویداد شکست بخورد، نیاز به مکانیزم‌های تلاش مجدد و مدیریت خطاها وجود دارد.</li></ul>
<ul><li><strong>مثال:</strong> اگر سرویس ارسال ایمیل از کار بیفتد، پیام‌ها باید در صف باقی بمانند یا به Dead Letter Queue منتقل شوند.</li></ul>
<ul><li><strong>راه‌حل:</strong> استفاده از Dead Letter Queues و مکانیزم‌های Retry با تعداد محدود.</li></ul>

<h3>۳. تضمین سازگاری نهایی (Eventual Consistency)</h3>
<ul><li><strong>چالش:</strong> به دلیل پردازش ناهمزمان، سیستم ممکن است برای مدتی ناسازگار باشد (مانند تأخیر در به‌روزرسانی موجودی).</li></ul>
<ul><li><strong>مثال:</strong> در یک سیستم رزرو، ممکن است رزرو تأیید شود، اما موجودی به‌روز نشود.</li></ul>
<ul><li><strong>راه‌حل:</strong> استفاده از الگوهای مانند CQRS یا Event Sourcing برای مدیریت حالت و سازگاری.</li></ul>

<p>---</p>

<h2>موارد استفاده واقعی از معماری مبتنی بر رویداد</h2>

<ul><li><strong>اعلان‌های کاربران:</strong></li></ul>
   - <strong>سناریو:</strong> در یک اپلیکیشن شبکه اجتماعی، وقتی کاربری پستی منتشر می‌کند، رویداد «PostCreated» به دنبال‌کنندگان اطلاع‌رسانی می‌شود.
   - <strong>ابزار:</strong> RabbitMQ با Fanout Exchange یا AWS SNS.
   - <strong>مثال:</strong> توییتر از Kafka برای ارسال رویدادهای توییت به تایملاین‌های کاربران استفاده می‌کند.

<ul><li><strong>تشخیص تقلب:</strong></li></ul>
   - <strong>سناریو:</strong> در یک سیستم پرداخت، رویدادهای تراکنش به‌صورت بلادرنگ تحلیل می‌شوند تا الگوهای مشکوک شناسایی شوند.
   - <strong>ابزار:</strong> Kafka با Kafka Streams یا AWS Kinesis.
   - <strong>مثال:</strong> PayPal از پردازش جریان رویداد برای تشخیص فعالیت‌های غیرعادی استفاده می‌کند.

<ul><li><strong>تحلیل بلادرنگ:</strong></li></ul>
   - <strong>سناریو:</strong> یک پلتفرم تبلیغاتی کلیک‌های کاربران را برای تحلیل رفتار و بهینه‌سازی تبلیغات پردازش می‌کند.
   - <strong>ابزار:</strong> Apache Spark Streaming یا Kafka Streams.
   - <strong>مثال:</strong> گوگل از سیستم‌های مشابه برای تحلیل داده‌های تبلیغاتی استفاده می‌کند.

<p>---</p>

<h2>چه زمانی از EDA استفاده کنیم و چه زمانی نه؟</h2>

<h3>چه زمانی از EDA استفاده کنیم؟</h3>
<ul><li><strong>نیاز به پاسخگویی بلادرنگ:</strong> مانند اعلان‌های فوری یا تحلیل داده‌های زنده.</li></ul>
<ul><li><strong>سیستم‌های مقیاس‌پذیر:</strong> برای مدیریت بارهای کاری سنگین با مصرف‌کنندگان موازی.</li></ul>
<ul><li><strong>جداسازی سرویس‌ها:</strong> زمانی که سرویس‌ها باید مستقل از یکدیگر عمل کنند.</li></ul>
<ul><li><strong>پردازش‌های سنگین ناهمزمان:</strong> مانند رمزگذاری ویدئو یا ارسال ایمیل.</li></ul>
<ul><li><strong>مثال:</strong> پلتفرم‌های تجارت الکترونیک (مانند آمازون) برای پردازش سفارشات و اعلان‌ها.</li></ul>

<h3>چه زمانی از EDA استفاده نکنیم؟</h3>
<ul><li><strong>سیستم‌های ساده:</strong> برای برنامه‌های کوچک با بار کاری کم، پیچیدگی EDA غیرضروری است.</li></ul>
<ul><li><strong>نیاز به ترتیب دقیق:</strong> اگر ترتیب پردازش رویدادها حیاتی است و نمی‌توان به‌راحتی تضمین کرد.</li></ul>
<ul><li><strong>منابع محدود:</strong> اگر تیم یا زیرساخت برای مدیریت کارگزاران رویداد و مانیتورینگ کافی نیست.</li></ul>
<ul><li><strong>تراکنش‌های پیچیده:</strong> اگر سیستم نیاز به تراکنش‌های همزمان با سازگاری قوی (Strong Consistency) دارد.</li></ul>
<ul><li><strong>مثال:</strong> یک وبلاگ ساده مبتنی بر وردپرس نیازی به EDA ندارد.</li></ul>

<p>---</p>

<h2>خلاصه و بهترین روش‌ها برای طراحی سیستم‌های مبتنی بر رویداد</h2>

<h3>خلاصه</h3>
<ul><li><strong>معماری مبتنی بر رویداد (EDA):</strong> سیستمی که از رویدادها برای ارتباط ناهمزمان بین سرویس‌ها استفاده می‌کند.</li></ul>
<ul><li><strong>اجزای اصلی:</strong> رویدادها، تولیدکنندگان، مصرف‌کنندگان و کارگزاران رویداد (مانند Kafka، RabbitMQ، AWS EventBridge).</li></ul>
<ul><li><strong>مدل‌ها:</strong> Publish/Subscribe، Event Stream Processing و Event Sourcing.</li></ul>
<ul><li><strong>مزایا:</strong> جداسازی، مقیاس‌پذیری و پاسخگویی بلادرنگ.</li></ul>
<ul><li><strong>چالش‌ها:</strong> ترتیب رویدادها، مدیریت خطاها و سازگاری نهایی.</li></ul>
<ul><li><strong>درس کلیدی:</strong> EDA برای سیستم‌های مقیاس‌پذیر و بلادرنگ مناسب است، اما نیاز به ابزارها و فرآیندهای مناسب برای مدیریت پیچیدگی دارد.</li></ul>

<h3>بهترین روش‌ها</h3>
<ul><li><strong>انتخاب کارگزار مناسب:</strong></li></ul>
   - از Kafka برای پردازش جریان‌های داده‌ای بزرگ‌مقیاس استفاده کنید.
   - از RabbitMQ برای پیام‌رسانی سبک و مسیریابی پیچیده استفاده کنید.
   - از AWS EventBridge برای سیستم‌های ابری مدیریت‌شده استفاده کنید.
<ul><li><strong>مدیریت ترتیب رویدادها:</strong></li></ul>
   - از پارتیشن‌های Kafka یا صف‌های FIFO در SQS برای حفظ ترتیب در هر کلید استفاده کنید.
<ul><li><strong>تضمین Idempotency:</strong></li></ul>
   - از شناسه‌های یکتا (مانند UUID) برای جلوگیری از پردازش تکراری رویدادها استفاده کنید.
<ul><li><strong>مدیریت خطاها:</strong></li></ul>
   - از Dead Letter Queues برای ذخیره رویدادهای ناموفق استفاده کنید.
   - مکانیزم‌های تلاش مجدد (Retry) را با تعداد محدود پیاده‌سازی کنید.
<ul><li><strong>مانیتورینگ و ردیابی:</strong></li></ul>
   - از ابزارهایی مانند Prometheus و Grafana برای نظارت بر تأخیر و نرخ خطا استفاده کنید.
   - از Zipkin یا Jaeger برای ردیابی توزیع‌شده رویدادها استفاده کنید.
<ul><li><strong>امنیت:</strong></li></ul>
   - ارتباطات را با SSL/TLS رمزگذاری کنید.
   - از احراز هویت و مجوزهای دسترسی (مانند IAM در AWS) استفاده کنید.
<ul><li><strong>شروع ساده:</strong></li></ul>
   - با یک سیستم ساده شروع کنید و با رشد نیازها به مدل‌های پیچیده‌تر (مانند Event Sourcing) مهاجرت کنید.

<p>---</p>

<h2>منابع پیشنهادی برای مطالعه بیشتر</h2>

<ul><li><em>Designing Data-Intensive Applications</em> نوشته مارتین کلپمن: کتابی جامع برای یادگیری معماری‌های مبتنی بر رویداد.</li></ul>
<ul><li><em>The System Design Primer</em> (منبع متن‌باز در GitHub): راهنمایی برای طراحی سیستم‌های مقیاس‌پذیر.</li></ul>
<ul><li>وبلاگ‌های مهندسی:</li></ul>
   - <em>Netflix Tech Blog</em>: مقالات در مورد استفاده از Kafka و Event Sourcing.
   - <em>AWS Blog</em>: توضیحات در مورد AWS EventBridge و Kinesis.
   - <em>Uber Engineering Blog</em>: مقالات در مورد پردازش رویدادها در مقیاس بزرگ.
<ul><li>دوره‌های آنلاین:</li></ul>
   - <em>Grokking the System Design Interview</em> در DesignGuru.io
   - <em>System Design Course</em> در Educative.io
<ul><li>مستندات رسمی:</li></ul>
   - <a href="https://kafka.apache.org/documentation/">Apache Kafka Documentation</a>
   - <a href="https://www.rabbitmq.com/documentation.html">RabbitMQ Documentation</a>
   - <a href="https://docs.aws.amazon.com/eventbridge/">AWS EventBridge Documentation</a>

<p>---</p>

<p>این سند مفهوم معماری‌های مبتنی بر رویداد را به‌صورت جامع توضیح داده و برای مستندسازی آموزشی و یادگیری طراحی سیستم مناسب است. در صورت نیاز به توضیحات عمیق‌تر یا مثال‌های بیشتر، لطفاً اطلاع دهید!</p>

                <div class="alert alert-info" style="margin-top: 2rem;">
                    <strong>نکته:</strong> این مطلب بخشی از مجموعه آموزش طراحی سیستم است. برای مطالعه سایر مطالب، از منوی کناری استفاده کنید.
                </div>
            </article>
        </main>
    </div>

    <footer>
        <div class="footer-content">
            <p>&copy; 2024 آموزش طراحی سیستم - تمام حقوق محفوظ است</p>
            <p>آخرین به‌روزرسانی: 2025-07-12</p>
        </div>
    </footer>

    <script src="../../js/script.js"></script>
</body>
</html>
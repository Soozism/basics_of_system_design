# طراحی سیستم پیام‌رسان مشابه واتس‌اپ برای مصاحبه‌های طراحی سیستم

## مقدمه
طراحی یک سیستم پیام‌رسان مشابه واتس‌اپ یکی از سوالات محبوب در مصاحبه‌های طراحی سیستم است که توانایی کاندیدا در مدیریت سیستم‌های توزیع‌شده، مقیاس‌پذیر و امن را ارزیابی می‌کند. این سیستم باید پیام‌رسانی بلادرنگ، تحمل خطا، امنیت بالا و تجربه کاربری یکپارچه‌ای ارائه دهد. این سند به بررسی نیازمندی‌ها، معماری، اجزای سیستم، مدل‌سازی داده‌ها، مدیریت پیام‌ها، مقیاس‌پذیری، امنیت، و نکات مصاحبه برای مهندسان نرم‌افزار فارسی‌زبان می‌پردازد.

---

## نیازمندی‌های سیستم

### نیازمندی‌های کارکردی (Functional Requirements)
1. **پیام‌رسانی یک‌به‌یک:** کاربران می‌توانند پیام‌های متنی، تصویری یا صوتی را به یکدیگر ارسال کنند.
2. **پیام‌رسانی گروهی:** پشتیبانی از چت‌های گروهی با تعداد زیادی کاربر.
3. **نوتیفیکیشن‌ها:** ارسال اعلان‌های فوری (Push Notifications) برای پیام‌های جدید.
4. **وضعیت تحویل:** نمایش وضعیت پیام (ارسال‌شده، تحویل‌شده، خوانده‌شده).
5. **مدیریت مخاطبان:** امکان افزودن، حذف و مدیریت لیست مخاطبان.
6. **پیام‌های آفلاین:** ذخیره و تحویل پیام‌ها به کاربران آفلاین.

### نیازمندی‌های غیرکارکردی (Non-Functional Requirements)
1. **مقیاس‌پذیری:** پشتیبانی از میلیاردها کاربر و تریلیون‌ها پیام در روز.
2. **قابلیت اطمینان:** آپ‌تایم 99.99% برای جلوگیری از قطعی سرویس.
3. **عملکرد:** تحویل پیام در کمتر از 100 میلی‌ثانیه برای تجربه بلادرنگ.
4. **امنیت و حریم خصوصی:** رمزنگاری سرتاسری (End-to-End Encryption) برای حفاظت از پیام‌ها.
5. **قابلیت نگهداری:** طراحی ماژولار برای سهولت توسعه و عیب‌یابی.
6. **همگام‌سازی:** پشتیبانی از چندین دستگاه با همگام‌سازی پیام‌ها.

---

## معماری سطح بالا

### اجزای سیستم
1. **کلاینت:** اپلیکیشن‌های موبایل و وب برای تعامل کاربران.
2. **Load Balancer:** توزیع ترافیک بین سرورهای پیام‌رسان.
3. **سرورهای پیام‌رسان:** مدیریت ارسال، دریافت و همگام‌سازی پیام‌ها.
4. **سرویس نوتیفیکیشن:** ارسال اعلان‌های فوری با استفاده از APNs (اپل) و FCM (گوگل).
5. **پایگاه داده:** ذخیره‌سازی پیام‌ها، اطلاعات کاربران و گروه‌ها.
6. **کش:** ذخیره‌سازی داده‌های پراستفاده برای دسترسی سریع.
7. **سیستم پیام‌رسانی (Message Queue):** مدیریت پیام‌های آفلاین و پردازش غیرهمزمان.
8. **لایه امنیتی:** رمزنگاری پیام‌ها و احراز هویت کاربران.

### دیاگرام معماری
```
[کلاینت: وب/موبایل] <--> [Load Balancer]
                             |
                      [سرورهای پیام‌رسان]
                             |
                    ----------------------
                    |                    |
               [کش: Redis]         [پایگاه داده: Cassandra]
                    |                    |
                [سرویس نوتیفیکیشن]   [صف پیام: Kafka]
                    |                    |
                  [لایه امنیتی: E2E Encryption]
```

---

## مدل‌سازی داده‌ها

### ساختار داده‌ها
1. **جدول کاربران (Users):**
   - **کلیدها:** `user_id` (کلید اصلی)، `username`، `phone_number`، `public_key` (برای رمزنگاری)، `last_seen`
   - **مثال:**
     ```json
     {
       "user_id": "u123",
       "username": "ali_rezaei",
       "phone_number": "+989123456789",
       "public_key": "RSA_public_key",
       "last_seen": "2025-07-12T12:00:00Z"
     }
     ```
2. **جدول مخاطبان (Contacts):**
   - **کلیدها:** `user_id`، `contact_id`
   - **مثال:**
     ```json
     {
       "user_id": "u123",
       "contact_id": "u456"
     }
     ```
3. **جدول پیام‌ها (Messages):**
   - **کلیدها:** `message_id` (کلید اصلی)، `sender_id`، `receiver_id` (یا `group_id`)، `content` (رمزنگاری‌شده)، `timestamp`، `status` (ارسال‌شده/تحویل‌شده/خوانده‌شده)
   - **مثال:**
     ```json
     {
       "message_id": "m789",
       "sender_id": "u123",
       "receiver_id": "u456",
       "content": "encrypted_message",
       "timestamp": "2025-07-12T12:01:00Z",
       "status": "delivered"
     }
     ```
4. **جدول گروه‌ها (Groups):**
   - **کلیدها:** `group_id` (کلید اصلی)، `group_name`، `members` (لیست `user_id`ها)، `created_at`
   - **مثال:**
     ```json
     {
       "group_id": "g101",
       "group_name": "کارگروه پروژه",
       "members": ["u123", "u456", "u789"],
       "created_at": "2025-07-12T12:00:00Z"
     }
     ```

### انتخاب پایگاه داده
- **NoSQL (مانند Cassandra یا DynamoDB):**
  - مناسب برای مقیاس‌پذیری افقی و نوشتن/خواندن سریع پیام‌ها.
  - پشتیبانی از داده‌های توزیع‌شده برای چت‌های گروهی.
- **کش (Redis):**
  - ذخیره‌سازی وضعیت آنلاین کاربران و پیام‌های اخیر.
- **SQL (اختیاری):**
  - برای داده‌های رابطه‌ای مانند مدیریت کاربران و گروه‌ها.

---

## طراحی API و جریان تعامل

### APIهای اصلی
1. **ارسال پیام:**
   - **درخواست:** `POST /api/messages`
   - **بدنه درخواست:**
     ```json
     {
       "sender_id": "u123",
       "receiver_id": "u456",
       "content": "سلام، چطور می‌توانم به شما کمک کنم؟",
       "timestamp": "2025-07-12T12:01:00Z"
     }
     ```
   - **پاسخ:**
     ```json
     {
       "message_id": "m789",
       "status": "sent"
     }
     ```
2. **دریافت پیام‌ها:**
   - **درخواست:** `GET /api/messages?user_id=u123&receiver_id=u456`
   - **پاسخ:**
     ```json
     [
       {
         "message_id": "m789",
         "sender_id": "u123",
         "receiver_id": "u456",
         "content": "encrypted_message",
         "timestamp": "2025-07-12T12:01:00Z",
         "status": "delivered"
       }
     ]
     ```
3. **ایجاد گروه:**
   - **درخواست:** `POST /api/groups`
   - **بدنه درخواست:**
     ```json
     {
       "group_name": "کارگروه پروژه",
       "members": ["u123", "u456", "u789"]
     }
     ```
   - **پاسخ:**
     ```json
     {
       "group_id": "g101",
       "group_name": "کارگروه پروژه"
     }
     ```

### جریان تعامل
1. **ارسال پیام:**
   - کلاینت پیام را با رمزنگاری سرتاسری به سرور ارسال می‌کند.
   - سرور پیام را در صف (Kafka) و پایگاه داده ذخیره می‌کند.
   - اگر گیرنده آنلاین است، پیام از طریق WebSocket تحویل می‌شود.
   - نوتیفیکیشن از طریق APNs/FCM ارسال می‌شود.
2. **دریافت پیام‌ها:**
   - کلاینت درخواست پیام‌های جدید را از سرور می‌گیرد.
   - سرور پیام‌ها را از پایگاه داده یا کش بازیابی کرده و به کلاینت بازمی‌گرداند.
3. **همگام‌سازی:**
   - پیام‌ها با استفاده از `timestamp` یا `message_id` مرتب شده و بین دستگاه‌ها همگام‌سازی می‌شوند.

---

## مدیریت تحویل پیام، ترتیب و همگام‌سازی

### تحویل پیام
- **بلادرنگ:** استفاده از WebSocket برای تحویل پیام به کاربران آنلاین.
- **آفلاین:** ذخیره پیام‌ها در صف (Kafka) و تحویل پس از آنلاین شدن کاربر.
- **تضمین تحویل:** استفاده از تأییدیه‌های (Acknowledgements) برای به‌روزرسانی وضعیت پیام (ارسال‌شده، تحویل‌شده، خوانده‌شده).

### ترتیب پیام‌ها
- **چالش:** اطمینان از ترتیب صحیح پیام‌ها در چت‌های گروهی یا چنددستگاهی.
- **راه‌حل:**
  - افزودن `timestamp` و `message_id` به هر پیام.
  - مرتب‌سازی پیام‌ها در کلاینت بر اساس `timestamp`.

### همگام‌سازی بین دستگاه‌ها
- **چالش:** نمایش پیام‌های یکسان در چندین دستگاه کاربر.
- **راه‌حل:**
  - ذخیره پیام‌ها در پایگاه داده با `user_id` و `device_id`.
  - استفاده از WebSocket یا Polling برای به‌روزرسانی بلادرنگ.
  - کش کردن پیام‌های اخیر در Redis برای دسترسی سریع.

---

## مقیاس‌پذیری و قابلیت اطمینان

### مقیاس‌پذیری
- **چالش:** مدیریت میلیاردها کاربر و تریلیون‌ها پیام.
- **راه‌حل‌ها:**
  - **Load Balancer:** توزیع ترافیک با AWS ALB یا Nginx.
  - **مقیاس‌بندی افقی:** استفاده از Kubernetes برای سرورهای پیام‌رسان.
  - **پایگاه داده توزیع‌شده:** Cassandra با پارتیشن‌بندی برای ذخیره پیام‌ها.
  - **صف پیام:** Apache Kafka برای پردازش غیرهمزمان پیام‌ها و آنالیتیکس.

### قابلیت اطمینان
- **چالش:** جلوگیری از قطعی سرویس و از دست رفتن پیام‌ها.
- **راه‌حل‌ها:**
  - **افزونگی:** استفاده از چندین منطقه (Multi-Region) در AWS.
  - **پشتیبان‌گیری:** ذخیره پیام‌ها در Replicaهای متعدد.
  - **Failover:** جابجایی خودکار به سرورهای سالم با Route 53.

---

## امنیت و حریم خصوصی

### رمزنگاری سرتاسری (End-to-End Encryption)
- **روش:** استفاده از پروتکل Signal یا مشابه برای رمزنگاری پیام‌ها.
  - هر کاربر یک جفت کلید عمومی/خصوصی (RSA یا ECC) دارد.
  - پیام‌ها با کلید عمومی گیرنده رمزنگاری شده و فقط با کلید خصوصی رمزگشایی می‌شوند.
- **مزایا:** حتی سرورها نمی‌توانند محتوای پیام‌ها را بخوانند.

### احراز هویت
- **روش:** استفاده از OAuth 2.0 یا OTP (رمز یک‌بارمصرف) برای ورود کاربران.
- **محدودیت نرخ:** جلوگیری از حملات Brute Force با Rate Limiting.

### حفاظت در برابر سوءاستفاده
- **فیلتر محتوا:** بررسی پیام‌ها برای شناسایی محتوای مخرب یا اسپم.
- **گزارش کاربران:** امکان گزارش پیام‌های غیرمجاز توسط کاربران.

---

## مدیریت پیام‌های آفلاین و صف‌بندی

### پیام‌های آفلاین
- **چالش:** تحویل پیام به کاربران آفلاین.
- **راه‌حل:**
  - ذخیره پیام‌ها در Apache Kafka تا زمانی که کاربر آنلاین شود.
  - ارسال نوتیفیکیشن برای اطلاع‌رسانی به کاربر.
  - همگام‌سازی پیام‌ها پس از اتصال با استفاده از `message_id`.

### صف‌بندی پیام‌ها
- **روش:** استفاده از Kafka یا RabbitMQ برای مدیریت پیام‌های غیرهمزمان.
- **مزایا:** مقیاس‌پذیری بالا و تحمل خطا در برابر حجم زیاد پیام‌ها.

---

## تریدآف‌های طراحی

1. **عملکرد در مقابل امنیت:**
   - رمزنگاری سرتاسری تأخیر را افزایش می‌دهد.
   - **تصمیم:** استفاده از ECC به‌جای RSA برای رمزنگاری سریع‌تر.
2. **ذخیره‌سازی پیام‌ها در مقابل حریم خصوصی:**
   - ذخیره پیام‌ها در سرور برای همگام‌سازی آسان‌تر است اما حریم خصوصی را کاهش می‌دهد.
   - **تصمیم:** ذخیره پیام‌های رمزنگاری‌شده و حذف پس از مدت مشخص.
3. **بلادرنگ در مقابل مقیاس‌پذیری:**
   - WebSocket برای پیام‌رسانی بلادرنگ منابع زیادی مصرف می‌کند.
   - **تصمیم:** ترکیب WebSocket برای کاربران فعال و Polling برای کاربران با اتصال ضعیف.

---

## نکات برای ارائه طراحی در مصاحبه

1. **شروع با نیازمندی‌ها:**
   - نیازمندی‌های کارکردی (مانند پیام‌رسانی گروهی) و غیرکارکردی (مانند مقیاس‌پذیری) را با مصاحبه‌کننده تأیید کنید.
2. **ارائه دیاگرام معماری:**
   - دیاگرام ساده‌ای رسم کنید که اجزا (مانند Load Balancer، Kafka، Cassandra) را نشان دهد.
3. **توضیح NFRها:**
   - برای هر NFR (مانند امنیت یا مقیاس‌پذیری)، راه‌حل‌های پیشنهادی را توضیح دهید.
   - مثال: استفاده از Kafka برای پیام‌های آفلاین.
4. **بحث درباره تریدآف‌ها:**
   - نشان دهید که تعادل بین عملکرد، امنیت و هزینه را درک می‌کنید.
5. **جزئیات فنی:**
   - جزئیات مانند رمزنگاری، مدل داده، و انتخاب فناوری‌ها را شرح دهید.
6. **ارتباط شفاف:**
   - طراحی را به‌صورت ساختاریافته (نیازمندی‌ها → معماری → چالش‌ها) ارائه دهید.
   - به سوالات مصاحبه‌کننده پاسخ دهید و انعطاف‌پذیری نشان دهید.

---

## خلاصه
طراحی یک سیستم پیام‌رسان مشابه واتس‌اپ نیازمند توجه به نیازمندی‌های کارکردی (مانند پیام‌رسانی بلادرنگ و گروهی) و غیرکارکردی (مانند مقیاس‌پذیری و امنیت) است. معماری شامل Load Balancer، سرورهای پیام‌رسان، کش، پایگاه داده توزیع‌شده، و صف پیام است. رمزنگاری سرتاسری و مدیریت پیام‌های آفلاین برای امنیت و تجربه کاربری ضروری هستند. در مصاحبه، توانایی توضیح نیازمندی‌ها، ارائه دیاگرام واضح، بحث درباره تریدآف‌ها و تمرکز بر جزئیات فنی کلیدی است. با این رویکرد، می‌توانید یک سیستم مقیاس‌پذیر، امن و کاربرپسند طراحی کنید که برای مصاحبه‌های طراحی سیستم مناسب باشد.